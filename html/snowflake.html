<!DOCTYPE html>
<html lang="en">
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width, initial-scale=1">
<meta name=description content="
Snowflake is a system for circumventing Internet censorship.
Its blocking resistance comes from
the use of numerous, ultra-light, temporary proxies (“snowflakes”),
which accept traffic from censored clients using peer-to-peer WebRTC protocols
and forward it to a centralized bridge.
">
<title>Snowflake, a censorship circumvention system using temporary WebRTC proxies</title>
<style>
article {
	max-width: 50rem;
}
section {
	margin-top: 2.5rem;
}
h1 a, h2 a, h3 a {
	color: inherit;
	text-decoration: inherit;
}
h1 .number, h2 .number, h3 .number {
	padding-right: 0.75em;
}
address {
	font-style: inherit;
}
#toc ul {
	list-style-type: none;
}
a {
	color: slateblue;
	text-decoration: underline;
}
.cite {
	color: gray;
	text-decoration: none;
	white-space: nowrap;
}
.cite .number {
	color: slateblue;
	text-decoration: underline;
}
.nobreak {
	white-space: nowrap;
}
dt {
	font-weight: bold;
}
pre {
	background-color: #ccc4;
	padding: 0.25rem;
	overflow-x: auto;
}
samp {
}
kbd {
	font-style: italic;
	color: navy;
}
figure {
	margin-left: 0;
	margin-right: 0;
}
figure picture, figure table {
	margin-left: auto;
	margin-right: auto;
}
figure picture source, figure picture img {
	max-width: 100%;
	max-height: 18rem;
	height: auto;
}
figcaption {
	font-size: smaller;
}
th {
	font-weight: inherit;
}

/* For tab-nat-matching and fig-protocol-layers. */
.leftbrace, .upbrace {
	border-color: black;
	border-width: medium;
}
.leftbrace, #tab-nat-matching .leftbrace {
	padding: 1px 0;
	width: 0.25rem;
	border-right-style: solid;
	border-top-right-radius: 0.5rem;
	border-bottom-right-radius: 0.5rem;
}
.upbrace, #tab-nat-matching .upbrace {
	padding: 0 1px;
	height: 0.25rem;
	border-bottom-style: solid;
	border-bottom-left-radius: 0.5rem;
	border-bottom-right-radius: 0.5rem;
}
.leftbracelabel, .upbracelabel {
	font-size: small;
}
.leftbracelabel, #tab-nat-matching .leftbracelabel, #fig-protocol-layers .leftbracelabel {
	text-align: left;
}
.upbracelabel, #tab-nat-matching .upbracelabel, #fig-protocol-layers .upbracelabel {
	vertical-align: top;
}
#tab-nat-matching th, #tab-nat-matching td {
	padding: 1px 0.5ex;
}
#tab-nat-matching td {
	text-align: center;
}
#tab-nat-matching tr > th {
	text-align: center;
	white-space: nowrap;
}
#tab-nat-matching tr > th:first-child {
	text-align: right;
}
#tab-nat-matching td.y {
	background-color: #eee;
}
#tab-nat-matching td.n {
	background-color: #ddd;
}
#fig-protocol-layers table {
	border-spacing: 0;
}
#fig-protocol-layers td {
	padding: 0;
	text-align: left;
}
#fig-protocol-layers td.leftbracelabel {
	padding-left: 0.5rem;
}

@counter-style ref {
	system: extends numeric;
	prefix: "[";
	suffix: "] ";
}
#references ol {
	list-style: ref;
}
#references ol :target {
	background-color: gold;
}
.mark {
	color: darkorange;
	padding: 0 0.25ex;
	text-decoration: none;
}
.mark.hover, .mark.focus {
	background-color: palegoldenrod;
}
aside {
	background-color: aliceblue;
	border: thin solid powderblue;
	font-size: small;
	padding: 0.25em 0.5em;
	overflow: auto;
	margin-top: 4px;
}
aside.hover, aside.focus {
	background-color: palegoldenrod;
	border-color: goldenrod;
}
aside > * {
	margin-top: 0;
	margin-bottom: 0;
}
aside ul {
	padding-left: 1rem;
}
@media(min-width: 640px) {
	article {
		width: 70vw;
		max-width: 50rem;
		margin-left: 2rem;
	}
	aside[class~="note"], aside[class~="footnote"] {
		position: absolute;
		max-width: 24rem;
		margin-left: 2rem;
		margin-right: 1rem;
		left: calc(2rem + min(70vw, 50rem));
	}
}
</style>
<script type=module>
// Like https://gameprogrammingpatterns.com/script.js.
function position_notes() {
	let bottom = 0;
	for (let note of document.querySelectorAll("aside[id]")) {
		let ref = document.querySelector(`[href=${CSS.escape("#" + note.id)}]`);
		if (ref != null) {
			if (note.classList.contains("note") || note.classList.contains("footnote")) {
				note.style.top = `${Math.max(bottom, ref.offsetTop)}px`;
				bottom = note.offsetTop + note.offsetHeight;
			}
			// Highlight the corresponding note when the marker is hovered over / focused, and vice versa.
			for (let { on_event, off_event, class_ } of [
				{ on_event: "mouseover", off_event: "mouseout", class_: "hover" },
				{ on_event: "focus",     off_event: "blur",     class_: "focus" },
			]) {
				for (let elem of [ref, note]) {
					elem.addEventListener(on_event, event => {
						note.classList.add(class_);
						ref.classList.add(class_);
					});
					elem.addEventListener(off_event,  event => {
						note.classList.remove(class_);
						ref.classList.remove(class_);
					});
				}
			}
		}
	}
}
// Reposition margin notes when the screen is resized.
for (let event_name of ["DOMContentLoaded", "resize"]) {
	addEventListener(event_name, event => position_notes());
}
// Reposition margin notes when a details element is opened or closed.
for (let details of document.querySelectorAll("details")) {
	details.addEventListener("toggle", event => position_notes());
}
</script>
</head>
<body>

<article>
<header>
<h1>Snowflake, a censorship circumvention system using temporary WebRTC proxies</h1>

<address>
<ul id=authors>
<li>Cecylia Bocovich</li>
<li>Arlo Breault</li>
<li>David Fifield</li>
<li>Serene</li>
<li>Xiaokang Wang</li>
</ul>
<p>
<output id=authornote>
Authors are listed alphabetically.
</output>
</p>
<p>
This is the HTML version of our article about
<a href="https://snowflake.torproject.org/">Snowflake</a>.
It has the same content as the version in the conference proceedings,
with additional margin notes and links that did not fit in the print-oriented version.
</p>
</address>
<script>
// Randomize order of author list.
function shuffle(a) {
	const b = [...a];
	for (let i = 0; i < b.length; i++) {
		const j = Math.floor(Math.random() * (i + 1));
		[b[i], b[j]] = [b[j], b[i]];
	}
	return b;
}
const authorList = document.querySelector("#authors");
authorList.replaceChildren(...shuffle(authorList.querySelectorAll("li")));
document.querySelector("#authornote").textContent = "Authors are listed in random order.";
</script>
<ul id=links>
<li><a href="https://www.usenix.org/conference/usenixsecurity24/presentation/bocovich">USENIX Security 2024 page</a></li>
<li><a href="https://archive.org/details/snowflake-paper">Source code and data for this article</a></li>
</ul>
<p>
Last updated <time id=lastupdated>2024-05-14</time>.
</p>
</header>

<nav id=toc>
<h2>Contents</h2>
<ul>
<li><a href=#abstract>Abstract</a></li>
<li><a href=#intro><span class=number>1</span> Introduction</a></li>
<li><a href=#mechanics><span class=number>2</span> How it works</a>
<ul>
<li><a href=#rendezvous><span class=number>2.1</span> Rendezvous</a></li>
<li><a href=#connection><span class=number>2.2</span> Peer-to-peer connection establishment</a></li>
<li><a href=#data-transfer><span class=number>2.3</span> Data transfer</a></li>
</ul>
</li>
<li><a href=#fingerprinting><span class=number>3</span> Protocol fingerprinting</a></li>
<li><a href=#experience><span class=number>4</span> Experience</a>
<ul>
<li><a href=#clients><span class=number>4.1</span> Client counts and bandwidth</a></li>
<li><a href=#proxies><span class=number>4.2</span> Number and type of proxies</a></li>
<li><a href=#proxy-churn><span class=number>4.3</span> Proxy churn</a></li>
<li><a href=#multi-bridge><span class=number>4.4</span> Multiple bridges</a></li>
</ul>
</li>
<li><a href=#block><span class=number>5</span> Notable blocking attempts</a>
<ul>
<li><a href=#block-ru><span class=number>5.1</span> Blocking in Russia</a></li>
<li><a href=#block-ir><span class=number>5.2</span> Blocking in Iran</a></li>
<li><a href=#block-cn><span class=number>5.3</span> Blocking in China</a></li>
<li><a href=#block-tm><span class=number>5.4</span> Blocking in Turkmenistan</a></li>
</ul>
</li>
<li><a href=#future><span class=number>6</span> Future work</a></li>
<li><a href=#availability>Availability</a></li>
<li><a href=#acknowledgements>Acknowledgements</a></li>
<li><a href=#references>References</a></li>
<li><a href=#errata>Errata</a></li>
</ul>
</nav>

<section id=abstract>
<h2><a href=#abstract>Abstract</a></h2>

<p id=p1>
Snowflake is a system for circumventing Internet censorship.
Its blocking resistance comes from
the use of numerous, ultra-light, temporary proxies (“snowflakes”),
which accept traffic from censored clients using peer-to-peer WebRTC protocols
and forward it to a centralized bridge.
The temporary proxies are simple enough to be implemented in JavaScript,
in&nbsp;a web page or browser extension,
making them much cheaper to run than
a traditional proxy or VPN server.
The large and changing pool
of proxy addresses resists enumeration and blocking by a censor.
The system is designed with the assumption
that proxies may appear or disappear at any time.
Clients discover proxies dynamically
using a secure rendezvous protocol.
When an in-use proxy goes offline,
its client switches to another on the fly,
invisibly to upper network layers.
</p>

<p id=p2>
Snowflake has been deployed with success
in Tor Browser and Orbot for several years.
It has been a significant circumvention tool
during high-profile network disruptions,
including in Russia in&nbsp;2021 and Iran in&nbsp;2022.
In this paper, we explain the composition of Snowflake’s many parts,
give a history of deployment and blocking attempts,
and reflect on implications for circumvention generally.
</p>

</section>

<!--
General references:
  https://keroserene.net/snowflake/technical/#history
  https://www.bamsoftware.com/papers/thesis/#chap:snowflake
-->

<section id=intro data-number=1>
<h2><a href=#intro><span class=number>1</span> Introduction</a></h2>

<p id=p3>
Snowflake is a censorship circumvention system,
a&nbsp;system to enable network communication
despite interference by a censor.
Its blocking resistance comes from a large pool
of low-cost, temporary proxies
that varies over time
and offers a censor no fixed target for blocking.
The core research purpose of this paper
is to investigate experimentally to what extent
a circumvention system that makes the tradeoffs Snowflake does
can be effective against contemporary censors.
We&nbsp;will present the design of the system,
listing the many challenges of circumvention
and showing how Snowflake addresses them.
We&nbsp;will explain how Snowflake solves the technical challenge
of providing a good user experience
when proxies are individually unreliable.
We&nbsp;will document the reactions of national censors
through case studies in
Russia, Iran, China, and Turkmenistan
over more than three years of deployment.
On&nbsp;the way, we will provide quantitative evaluations
of various facets of the system,
including the number of clients served,
and the size and composition of the proxy pool.
</p>

<p id=p4>
Censorship circumvention systems may
be characterized on multiple axes.
Some systems imitate a common network protocol;
others try
not to look like any protocol in particular.
Some distribute connections over numerous proxy servers;
others concentrate on a single proxy
that is, for one reason or another, difficult for a censor to block.
What all circumvention systems have in common
is that they strive to increase the <em>cost</em>
to the censor of blocking them—whether that cost be in
research and development, human resources, and hardware;
or&nbsp;in the inevitable overblocking that results
when a censor tries to selectively block
some connections but not others.
On&nbsp;the spectrum of imitation to randomization,
Snowflake falls on the side of imitation;
on the scale of diffuse to concentrated, it&nbsp;is diffuse.
Snowflake’s defining quality is that it
pushes the idea of distributed, disposable
proxies to an extreme.
</p>

<p id=p5>
WebRTC is a suite of protocols
intended for real-time communication applications
on the web&nbsp;[<a href=#ref:rfc8825 class=cite>1</a>].
Video and voice chat are typical applications.
Snowflake exchanges WebRTC data formats
in the course of establishing a connection,
and uses WebRTC protocols to traverse of NAT (network address translation)
and to connect clients and proxies.
Crucially for Snowflake, WebRTC APIs
are available to JavaScript code in web browsers,
meaning it is possible to implement a proxy
in a web page or browser extension.
WebRTC is also usable outside a browser,
which is how we implement the Snowflake client program
and alternative, command line–based proxies.
</p>

<p id=p6>
As&nbsp;is usual in circumvention research,
we assume a threat model in which
<em class=firstterm>clients</em> reside in a network
controlled by a <em class=firstterm>censor</em>.
The censor has the power to inspect and interfere with
traffic that crosses the border of its network;
typical real-world censor behaviors include
inspecting IP addresses and hostnames,
checking packet contents for keywords,
blocking IP addresses, and injecting false DNS responses
and TCP RST packets.
The client wants to communicate with some
<em class=firstterm>destination</em> outside the censor’s network,
possibly with the aid of third-party <em class=firstterm>proxies</em>.
The censor is motivated to block the contents
of the client’s communication, or the destination itself.
The censor knows of the possibility of circumvention,
and therefore seeks to block not only direct communication with the destination,
but also indirect communication by way of a proxy or circumvention system.
Circumvention is accomplished when the client
can reliably reach any proxy,
because a proxy, being outside the censor’s control,
can then forward the client’s communication to any destination.
(In Snowflake, we separate the roles of temporary <em class=firstterm>proxies</em>
and a stable long-term <em class=firstterm>bridge</em>, but the idea is the same.)
The censor derives benefit
from permitting some forms of network access:
it&nbsp;cannot trivially “win”
by shutting down all communication,
but must be selective in its blocking decisions,
in order to optimize some objective of its own.
The art of censorship circumvention is
forcing the censor into a dilemma
of&nbsp;overblocking or underblocking,
by making circumvention traffic difficult to distinguish
from traffic that the censor prefers not to block.
</p>

<p id=p7>
Snowflake originates in two earlier projects:
flash proxy and uProxy.<a class=mark href=#n-1>&bull;</a>
Flash proxy&nbsp;<a href=#ref:Fifield2012a class=cite>[<span class=number>10</span>]</a>, like Snowflake, used
untrusted temporary JavaScript proxies in web browsers
forwarding to a central bridge,
but the link between client and proxy was WebSocket
rather than WebRTC,
which was then an emerging technology.
Flash proxy was deployed
from <time>2013</time> to&nbsp;<time>2016</time><a class=mark href=#n-2>&bull;</a>,
but never saw much use,
probably because WebSocket,
which lacks the built-in NAT traversal of WebRTC,
required clients to do complicated port forwarding.<a class=mark href=#n-3>&bull;</a>
uProxy&nbsp;<a href=#ref:uproxy class=cite>[<span class=number>38</span>]</a>, in one of its early incarnations<a class=mark href=#n-4>&bull;</a>,
pioneered the use of WebRTC proxies for circumvention.
uProxy’s proxies were browser-based,
but its trust and deployment model was different
from flash proxy’s and Snowflake’s.
Censored clients would arrange, out of band,
for an acquaintance outside the censor’s network
to run a proxy in their browser&nbsp;<a href=#ref:uproxy-design-doc class=cite>[<span class=number>39</span>]</a><a class=mark href=#n-5>&bull;</a>.
A&nbsp;personal trust relationship was necessary to prevent misuse,
since browser proxies fetched destination content directly—meaning
client activity would be attributed to the proxy,
and the proxy might inspect the client’s traffic.
Clients did not change proxies on the fly.
uProxy supported protocol obfuscation:
its packets could be transformed to resemble something
other than WebRTC.<a class=mark href=#n-6>&bull;</a>
This was possible because of
uProxy’s implementation as a privileged browser extension
with access to real sockets.
Because Snowflake uses ordinary unprivileged APIs,
its WebRTC can only look like WebRTC;
on the other hand, for the same reason,
Snowflake proxies are easier to deploy.
Like flash proxy, uProxy was active in the years
<time>2013</time>–<time>2016</time>.<a class=mark href=#n-7>&bull;</a>
</p>

<aside class=note id=n-1>
<ul>
<li><a href="https://lists.torproject.org/pipermail/tor-dev/2016-January/010310.html">“Snowflake is a webrtc pluggable transport inspired by flashproxy.”</a></li>
<li><a href="https://keroserene.net/snowflake/technical/#1-introduction">“It is inspired by and builds upon the previous work of Flashproxy. Snowflake is much like a hybrid of previous Pluggable Transports…”</a></li>
<li><a href="https://serene.cx/snowflake/#note-flashproxy">“…one could say that uProxy and flashproxy are the ancestors of snowflake.”</a></li>
</ul>
</aside>

<aside class=note id=n-2>
<ul>
<li><time>2013</time>: <a href="https://blog.torproject.org/combined-flash-proxy-pyobfsproxy-browser-bundles/">Combined flash proxy + pyobfsproxy browser bundles</a></li>
<li><time>2016</time>: <a href="https://bugs.torproject.org/17428#note_2203210">Remove Flashproxy from Tor Browser</a></li>
</ul>
</aside>

<aside class=note id=n-3>
<a href="https://gitlab.torproject.org/legacy/trac/-/wikis/doc/PluggableTransports/FlashProxy/Howto">Flash proxy howto</a>
</aside>

<aside class=note id=n-4>
“In one of its earlier incarnations”: uProxy
<a href="https://web.archive.org/web/20161211194847/https://blog.uproxy.org/2016/02/get-access-24x7-through-your-own-uproxy.html">pivoted from friend proxies to cloud servers</a>
and
<a href="https://lists.torproject.org/pipermail/tor-dev/2016-September/011489.html">added support for proxying through Tor</a> in <time>2016</time>.
</aside>

<aside class=note id=n-5>
“uProxy depends on leveraging existing trust relationships to to find and use a proxy.”
</aside>

<aside class=note id=n-6>
<a href="https://github.com/uProxy/uproxy-obfuscators">https://github.com/uProxy/uproxy-obfuscators</a>
</aside>

<aside class=note id=n-7>
<ul>
<li><time>2013</time>: <a href="https://events.ccc.de/congress/2013/wiki/Static:Lightning_Talks#Day_3">Serene’s 30C3 lightning talk on uProxy</a></li>
<li><time>2013</time>–<time>2016</time>: <a href="https://github.com/UWNetworksLab/uProxy-p2p/graphs/contributors">Contributions in uProxy-p2p</a></li>
</ul>
</aside>

<p id=p8>
Among existing circumvention systems,
the one that is most similar to Snowflake is MassBrowser&nbsp;<a href=#ref:Nasr2020a class=cite>[<span class=number>24</span>]</a><a class=mark href=#n-8>&bull;</a>,
which offers
proxying though volunteer proxies, called buddies.
MassBrowser’s architecture is similar to Snowflake’s:
there is a central component that coordinates
connections between clients and buddies,
which corresponds to a piece in Snowflake called the broker;
buddies are like our proxies.
Its trust model is intermediate between Snowflake’s and uProxy’s.
Buddies preferentially operate as one-hop proxies, as in uProxy,
but are not limited to proxying only for trusted friends.
To&nbsp;deter misuse, buddies specify a policy of
what categories of content they are willing to proxy.
The buddy software is
not constrained by a web browser environment,
and can, like uProxy, use protocol obfuscation
on the client–buddy link.<a class=mark href=#n-9>&bull;</a>
</p>

<aside class=note id=n-8>
<a href="https://github.com/net4people/bbs/issues/32">Reading group summary of MassBrowser</a>
</aside>

<aside class=note id=n-9>
<ul>
<li><span class=nobreak>§V-D</span>:
“We also implement traffic obfuscation to protect MassBrowser’s traffic
against traffic analysis attacks. Particularly, we have built a custom
implementation of the obfsproxy Tor pluggable transport tailored to work with
our MassBrowser implementation.”</li>
<li><span class=nobreak>§VI-A</span>:
“MassBrowser uses a custom protocol over TCP/UDP for the communications
between Clients and Buddies.”</li>
</ul>
</aside>

<p id=p9>
Other circumvention systems have used WebRTC,
though without Snowflake’s focus on numerous proxies.
Protozoa&nbsp;<a href=#ref:Barradas2020a class=cite>[<span class=number>2</span>]</a><a class=mark href=#n-10>&bull;</a>
and Stegozoa&nbsp;<a href=#ref:Figueira2022a class=cite>[<span class=number>12</span>]</a>
demonstrate point-to-point covert tunnels over WebRTC,
the former by directly replacing encoded media
with its own ciphertexts,
the latter using video steganography.
Significantly, where Snowflake now uses WebRTC data channels,
Protozoa and Stegozoa use WebRTC media streams,
which may have advantages for blocking resistance.
We will say more on this point in <a href=#fingerprinting>Section&nbsp;3</a>.
TorKameleon&nbsp;<a href=#ref:Vilalonga2023a class=cite>[<span class=number>40</span>]</a> is a WebRTC-based system
with the dual goals of resisting blocking
and complicating traffic correlation attacks.
It&nbsp;uses a recent draft programming interface called
WebRTC Encoded Transforms<a class=mark href=#n-11>&bull;</a>
to support Protozoa-like
embedding of data within media streams,
without invasive browser modifications.<a class=mark href=#n-12>&bull;</a>
<!--
Examples of Encoded Transforms in TorKameleon source code:
https://github.com/AfonsoVilalonga/TorKameleon/blob/c6ef7116043dfd74701ddb62f38606e748faf84b/PT/WebRTC/Client/public/js/main.js#L225
  const transformStream = new TransformStream({
https://github.com/AfonsoVilalonga/TorKameleon/blob/c6ef7116043dfd74701ddb62f38606e748faf84b/PT/WebRTC/Client/public/js/modulators/addFrame.js#L8
  if (encodedFrame instanceof RTCEncodedVideoFrame && enconding.length > 0) {
Encoded Transforms (earlier called Insertable Streams) had been mentioned as a future possibility in Stegozoa:
https://dl.acm.org/doi/pdf/10.1145/3488932.3517419#page=12
-->
</p>

<aside class=note id=n-10>
<a href="https://github.com/net4people/bbs/issues/55">Reading group summary of Protozoa</a>
</aside>

<aside class=note id=n-11>
<ul>
<li><a href="https://w3c.github.io/webrtc-encoded-transform/">WebRTC Encoded Transform</a> W3C Editor’s Draft</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Using_Encoded_Transforms">Using WebRTC Encoded Transforms</a></li>
</ul>
</aside>

<aside class=note id=n-12>
<a href="https://lists.torproject.org/pipermail/anti-censorship-team/2023-February/000284.html">WebRTC Encoded Transform (or Insertable Streams) for media channels in Snowflake?</a>
</aside>

<!--
Very early versions of Lantern (circa 2014) used social network–based trusted proxies:
  https://web.archive.org/web/20140326223853/http://techpresident.com/news/wegov/24455/why-remarkably-similar-circumvention-tools-uproxy-and-lantern-are-not-overkill
  https://lists.torproject.org/pipermail/tor-dev/2014-March/006356.html "HOWTO use Lantern as a pluggable transport"
  https://web.archive.org/web/20130831160152/https://www.youtube.com/watch?v=aiPkCugE-RY
  https://web.archive.org/web/2oe_/http://wayback-fakeurl.archive.org/yt/aiPkCugE-RY
But it wasn’t WebRTC, so was less like Snowflake than uProxy was.
I’ll draw the line here, since even Tor bridges are “volunteer-operated” in a sense.
-->

<p id=p10>
Our goal in this paper is to provide a realistic assessment of Snowflake,
and neither to exaggerate its advantages,
nor disproportionately emphasize the limitations
of other systems.
Circumvention research is a cooperative enterprise,
and we recognize and support our colleagues who
design and maintain systems of their own.
With Snowflake, we have tried to explore a different point in the design space,
and by this exploration widen the scope of effective circumvention techniques.
We&nbsp;acknowledge that Snowflake will be a better choice in some
censorship environments and
worse in others; indeed,
one of the ideas we hope to convey
is that blocking resistance
can be meaningfully understood only in relation to a censor
and its particular resources, costs, and motivations.
</p>

<p id=p11>
As&nbsp;of <time datetime=2024-03-03>March 2024</time>,
Snowflake supports an estimated 35,000 average concurrent users<a class=mark href=#calc-1>&bull;</a>
at an average total transfer rate of 2.7&nbsp;Gbit/s<a class=mark href=#calc-2>&bull;</a>,
which works out to around 29&nbsp;TB of circumvention traffic per day.
</p>

<aside class=calc id=calc-1>
<details>
<summary>Calculation</summary>
<pre><samp>&gt; <kbd>library("tidyverse")</kbd>
&gt; <kbd>WANTED_FINGERPRINTS &lt;- c(
    "7659DA0F96B156C322FBFF3ACCC9B9DC01C27C73" = "snowman",
    "5481936581E23D2D178105D44DB6915AB06BFB7F" = "snowflake-01",
    "91DA221A149007D0FD9E5515F5786C3DD07E4BB0" = "snowflake-02"
  )</kbd>
&gt; <kbd>read_csv("figures/users/userstats-bridge-transport-multi.csv") %&gt;%
    filter(transport == "snowflake" &amp; fingerprint %in% names(WANTED_FINGERPRINTS)) %&gt;%
    filter(date &lt; "2024-03-04") %&gt;%
    mutate(users = users / (coverage / pmax(num_instances, coverage))) %&gt;%
    group_by(date, transport) %&gt;% summarize(users = sum(users, na.rm = TRUE), .groups = "drop") %&gt;%
    tail()</kbd>
# A tibble: 6 × 3
  date       transport  users
  &lt;date&gt;     &lt;chr&gt;      &lt;dbl&gt;
1 2024-02-27 snowflake 49377.
2 2024-02-28 snowflake 49816.
3 2024-02-29 snowflake 49140.
4 2024-03-01 snowflake 42784.
5 2024-03-02 snowflake 35137.
6 2024-03-03 snowflake 34141.
</samp></pre>
</details>
</aside>

<aside class=calc id=calc-2>
<details>
<summary>Calculation</summary>
<pre><samp>&gt; <kbd>library("tidyverse")</kbd>
&gt; <kbd>WANTED_FINGERPRINTS &lt;- c(
    "7659DA0F96B156C322FBFF3ACCC9B9DC01C27C73" = "snowman",
    "5481936581E23D2D178105D44DB6915AB06BFB7F" = "snowflake-01",
    "91DA221A149007D0FD9E5515F5786C3DD07E4BB0" = "snowflake-02"
  )</kbd>
&gt; <kbd>options(width = 200)</kbd>
&gt; <kbd>userstats &lt;- read_csv("figures/users/userstats-bridge-transport-multi.csv") %&gt;%
    filter(fingerprint %in% names(WANTED_FINGERPRINTS)) %&gt;%
    mutate(users = users / (coverage / pmax(num_instances, coverage)))</kbd>
&gt; <kbd>bandwidth &lt;- read_csv("figures/users/bandwidth-multi.csv") %&gt;%
    filter(fingerprint %in% names(WANTED_FINGERPRINTS)) %&gt;%
    filter(coverage &gt; 0) %&gt;%
    mutate(bytes = bytes / (coverage / pmax(num_instances, coverage))) %&gt;%
    pivot_wider(id_cols = c(date, fingerprint), names_from = c(type), values_from = c(bytes)) %&gt;%
    mutate(
      good_read = read - `dirreq-read`,
      good_write = write - `dirreq-write`,
      good_avg = (good_read + good_write) / 2,
      good_avg_bps = good_avg*8/86400,
    )</kbd>
&gt; <kbd>left_join(userstats, bandwidth, by = c("date", "fingerprint")) %&gt;%
    # Subtract out the pro-rated fraction of non-snowflake transports (basically negligible).
    group_by(date, fingerprint) %&gt;%
    mutate(across(c(read, write, `dirreq-read`, `dirreq-write`, good_read, good_write, good_avg), &amp;nbsp; .x * users / sum(users))) %&gt;%
    ungroup() %&gt;%
    filter(transport == "snowflake") %&gt;%
    filter(date &lt; "2024-03-04") %&gt;%
    group_by(date) %&gt;%
    summarize(
      date = last(date),
      across(c(read, write, `dirreq-read`, `dirreq-write`, good_read, good_write, good_avg, good_avg_bps), sum, na.rm = TRUE)
    ) %&gt;%
    mutate(
      across(c(read, write, `dirreq-read`, `dirreq-write`, good_read, good_write, good_avg), scales::label_bytes(units = "auto_si", accuracy = 0.01)),
      across(c(good_avg_bps), scales::label_number(scale_cut = scales::cut_si("bit"), accuracy = 0.01)),
    ) %&gt;%
    arrange(date) %&gt;% tail()</kbd>
# A tibble: 6 × 9
  date       read     write    `dirreq-read` `dirreq-write` good_read good_write good_avg good_avg_bps
  &lt;date&gt;     &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;         &lt;chr&gt;          &lt;chr&gt;     &lt;chr&gt;      &lt;chr&gt;    &lt;chr&gt;
1 2024-02-27 39.25 TB 39.18 TB 12.84 GB      288.56 GB      39.24 TB  38.89 TB   39.06 TB 3.62 Gbit
2 2024-02-28 39.89 TB 39.82 TB 13.27 GB      299.37 GB      39.87 TB  39.52 TB   39.70 TB 3.68 Gbit
3 2024-02-29 39.74 TB 39.66 TB 13.13 GB      286.72 GB      39.72 TB  39.37 TB   39.55 TB 3.66 Gbit
4 2024-03-01 36.61 TB 36.48 TB 10.38 GB      204.50 GB      36.60 TB  36.28 TB   36.44 TB 3.38 Gbit
5 2024-03-02 29.89 TB 29.77 TB 7.78 GB       145.68 GB      29.89 TB  29.63 TB   29.76 TB 2.76 Gbit
6 2024-03-03 28.89 TB 28.78 TB 7.17 GB       136.40 GB      28.88 TB  28.64 TB   28.76 TB 2.66 Gbit
</samp></pre>
</details>
</aside>

</section>

<section id=mechanics data-number=2>
<h2><a href=#mechanics><span class=number>2</span> How it works</a></h2>

<figure id=fig-architecture data-number=1>
<picture>
<img src=architecture.jpg width=2100 height=600 alt="
A painted diagram showing the components of Snowflake.
It progresses from the “Censor” on the left (in red) to the “Destination” on the right (depicted as a white cloud).
The “Client” (inside the censor), “Broker”, and “Bridge” are green ovals.
Three smaller “STUN” servers are smaller purple ovals.
The “Snowflake Proxies” are drawn as snowflakes, with one of them being larger to serve as a representative.
There are double-headed arrows between the client and a STUN server,
between the client and the broker (through “Indirect rendezvous §2.1”),
between the snowflake proxy and a STUN server,
between the snowflake proxy and the broker (labeled “Rendezvous polling §2.1”),
between the client and the snowflake proxy (labeled “Peer-to-peer WebRTC §2.2”),
between the snowflake proxy and the bridge (labeled “WebSocket §2.3”),
and between the bridge and the destination.
">
</picture>
<figcaption>
<a href=#fig-architecture>Figure&nbsp;1</a>:
Architecture of Snowflake.
The client contacts the broker through an indirect rendezvous channel with high blocking resistance.
The broker matches the client with one of the proxies that are currently polling.
The client and proxy connect to one another using WebRTC.
The proxy connects to the bridge,
then begins copying traffic in both directions.
If&nbsp;the proxy disappears,
the client does another rendezvous
and resumes its session with a new proxy.
</figcaption>
</figure>

<p id=p12>
A&nbsp;Snowflake proxy connection proceeds in three phases.
First, there is rendezvous, in which a client
indicates its need for circumvention service
and is matched with a temporary proxy.
Rendezvous is facilitated by a central server called the broker.
Then, there is connection establishment,
where the client and its proxy connect to each other
with WebRTC, using information exchanged during rendezvous.
Finally, there is data transfer,
where the proxy transports data
between the client and the bridge.
The bridge is responsible for directing the client’s traffic
to its eventual destination
(in&nbsp;our case, by feeding it into the Tor network).
<a href=#fig-architecture>Figure&nbsp;1</a> illustrates the process.
</p>

<p id=p13>
These phases repeat as needed, as temporary proxies come and&nbsp;go.
Proxy failure is not an abnormal condition—it&nbsp;happens,
for example, when
a browser running a proxy is closed.
A&nbsp;client builds a circumvention session over
a sequence of proxies, switching to a new proxy
whenever the current one stops working.
State variables stored at the client and the bridge
let the session pick up where it left off.
The change of proxies is invisible to applications using Snowflake
(except for a brief delay for re-rendezvous).
The Snowflake software presents an abstraction of one uninterrupted connection.
</p>

<p id=p14>
It&nbsp;does not avail a censor to block the broker or bridge,
because Snowflake clients never contact either directly.
Clients reach the broker over an indirect rendezvous channel.
Access to the bridge is always mediated by a temporary proxy.
</p>

<section id=rendezvous data-number=2.1>
<h3><a href=#rendezvous><span class=number>2.1</span> Rendezvous</a></h3>

<p id=p15>
A&nbsp;session begins with the client sending a rendezvous message to the broker.
An&nbsp;ambient population of proxies
constantly polls the broker to check for clients in need of service.
The broker matches the client with an available proxy,
taking into account factors like NAT compatibility.<a class=mark href=#n-13>&bull;</a>
</p>

<aside class=note id=n-13>
NAT type
<a href="https://gitlab.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/-/blob/9edaee65470a1483bbdbe984e5e15a885f1e95d2/broker/ipc.go#L236">is currently the only constraint</a>,
but
<a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40251#note_2903271">protocol versions</a>
may become a consideration in the future.
</aside>

<p id=p16>
The client’s rendezvous message<a class=mark href=#n-14>&bull;</a>
is a bundle of data that the broker will need in order to match the client with a proxy,
and that the proxy will need in order to connect to the client.
The most important part of the rendezvous message is a
Session Description Protocol (SDP) <em class=firstterm>offer</em>&nbsp;<a href=#ref:rfc8839 class=cite>[<span class=number>27</span>]</a>,
which contains the information needed for a WebRTC connection,
such as the client’s external IP addresses
and cryptographic data to secure a later key exchange<a class=mark href=#n-15>&bull;</a>.
The broker gives the client’s offer to a currently polling proxy,
which sends back an SDP <em class=firstterm>answer</em>
with its share of connection details.
The broker forwards the proxy’s answer to the client,
and client and proxy then connect to one other directly.
In&nbsp;WebRTC terms, this offer/<wbr>answer exchange is called
“signaling”&nbsp;<a href=#ref:rfc8825 class=cite>[<span class=number>1</span>&nbsp;§2.2]</a>, and here the broker acts as a signaling server.
To&nbsp;gather the information for an SDP offer or answer,
clients and proxies communicate with third-party servers,
called STUN servers,
before contacting the broker.
We&nbsp;will say more about how STUN is used in <a href=#connection>Section&nbsp;2.2</a>.
Connecting to STUN servers is a normal part of WebRTC,
though there are fingerprinting considerations
that we cover in <a href=#fingerprinting>Section&nbsp;3</a>.
</p>

<aside class=note id=n-14>
<a href="https://gitlab.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/-/blob/9edaee65470a1483bbdbe984e5e15a885f1e95d2/common/messages/client.go#L64"><code>ClientPollRequest</code></a>
</aside>

<aside class=note id=n-15>
Specifically, a <a href="https://www.rfc-editor.org/rfc/rfc8122.html#section-5">certificate fingerprint</a>.
</aside>

<figure id=fig-rendezvous data-number=2>
<picture>
<source srcset=rendezvous.svg type="image/svg+xml" width=1001 height=581>
<img src=rendezvous.png width=1001 height=581 alt="
Diagram showing communication between three parallel tracks:
“Client” (inside a shaded region indicating the censor),
“Broker”, and “Proxy”.
Broker←Proxy: “Poll: any pending clients?”
Broker→Proxy: “No pending client”
Broker←Proxy: “Poll: any pending clients?”
Client→Broker: “Rendezvous message (client’s WebRTC offer)”
Broker→Proxy: “Here is a client (forward client’s offer)”
Broker←Proxy: “I will serve this client (proxy’s WebRTC answer)”
Client←Broker: “Rendezvous response (forward proxy’s answer)”
Broker→Proxy: “Acknowledged”
">
</picture>
<figcaption>
<a href=#fig-rendezvous>Figure&nbsp;2</a>:
Information exchange in Snowflake rendezvous.
When the broker makes a match,
the proxy receives the client’s SDP offer,
then re-connects to send back its SDP answer.
It&nbsp;all happens during one round trip
from the client’s point of view.
Not shown is the indirect channel
the client uses to access the broker.
</figcaption>
</figure>

<p id=p17>
Interaction with the broker uses a “long-polling” model,
shown abstractly in <a href=#fig-rendezvous>Figure&nbsp;2</a>.
Proxies poll the broker periodically,
using ordinary HTTPS requests.
The broker holds proxy polling requests open for a few seconds,
waiting for a client rendezvous message.
If&nbsp;none arrives, the broker sends a response that says “no clients”
and the proxy goes to sleep until its next poll.
When a client does arrive,
the broker responds to the proxy’s poll request
with the client’s SDP offer.
The proxy re-connects to the broker to send back its SDP answer.
The broker sends the SDP answer to the client
and an acknowledgement to the proxy.
At&nbsp;this point rendezvous is finished:
client and proxy have what they need to connect.
</p>

<p id=p18>
Proxies may contact the broker directly,
because they are assumed to be uncensored.
But clients must use an indirect,
blocking-resistant channel,
because any direct connection to the broker
would be easily blocked by a censor.
What is needed, essentially,
is a miniature circumvention system to
bootstrap the full system.
If&nbsp;clients have access to a bootstrap rendezvous method
that is good enough to reach the broker,
why is a more extensive circumvention system needed at all?
The answer is that the restricted scope of rendezvous
admits a wider range of solutions than general circumvention.
Techniques that would be too slow or expensive
for high-volume or interactive circumvention
may yet be suited to rendezvous,
because rendezvous happens infrequently
and transmits only small amounts of data.
</p>

<p id=p19>
The nice thing about rendezvous that it is modular and separable.
More than one method may be used,
and the methods need not have anything in common with the main system.
Anything that can be persuaded to convey a message
of about 1,500 bytes indirectly to the broker,
and return a response of about the same size,
may work as a Snowflake rendezvous module.<a class=mark href=#n-16>&bull;</a>
Snowflake now supports three rendezvous methods:
</p>

<aside class=note id=n-16>
<ul>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/25594">Broker: investigate non-domain-fronting secure client / proxy registrations</a></li>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/25874">DNS-based rendezvous for Snowflake</a></li>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/25594#note_2823395">Example: there is a chat bot (say, Telegram), that acts as a broker</a></li>
<li>Flash proxy email rendezvous
(<a href="https://gitweb.torproject.org/flashproxy.git/tree/flashproxy-reg-email">flashproxy-reg-email</a>,
<a href="https://gitweb.torproject.org/flashproxy.git/tree/facilitator/fp-registrar-email">fp-registrar-email</a>)
would not work for Snowflake, because unidirectional</li>
</ul>
</aside>

<dl>
<dt id=p20>Domain fronting</dt>
<dd>
<p>
In&nbsp;this method, the client does an HTTPS exchange with the broker
through an intermediary web service such as a content delivery network (CDN),
setting the externally visible hostname
(the TLS Server Name Indication, or SNI&nbsp;<a href=#ref:rfc6066 class=cite>[<span class=number>6</span>&nbsp;§3]</a>)
to a “front domain” different from the broker’s.
The CDN routes the HTTPS request to the broker according to the
the HTTP Host header, which, under TLS encryption,
reflects the actual hostname of the broker&nbsp;<a href=#ref:Fifield2015a class=cite>[<span class=number>11</span>]</a>.
A&nbsp;censor cannot easily block domain-fronted rendezvous
without also blocking unrelated connections to the front domain,
which should be selected to have high value to the censor.
The well-known drawback of domain fronting
is the high cost of CDN bandwidth,
but this is not a big problem
when it is used only for rendezvous.
</p>
</dd>

<dt id=p21>AMP cache</dt>
<dd>
<p>
AMP is a framework for web pages written in a restricted dialect of HTML.
Part of the framework is a free-to-use
cache server&nbsp;<a href=#ref:amp-cache class=cite>[<span class=number>26</span>]</a>.
The cache fetches AMP-conformant pages on demand,
making it effectively a restricted sort of HTTP proxy.
We&nbsp;have a module that encodes rendezvous messages to conform to AMP requirements,
allowing them to be exchanged with the broker via the AMP cache.<a class=mark href=#fn-1><sup>1</sup></a>
This rendezvous method is not easily blocked
without blocking the cache server as a whole.
It&nbsp;still technically requires domain fronting,
because the AMP cache protocol normally exposes the
broker’s hostname in the TLS SNI,
but it enlarges the set of usable intermediaries and front domains.
</p>
</dd>

<dt id=p22>SQS (Simple Queue Service)<a class=mark href=#n-17>&bull;</a></dt>
<dd>
<p>
Amazon SQS is a message queuing service designed for
communication between microservices.
Snowflake has the ability
(new at the time of this writing)
to use a message queue as a one-way communication channel.<a class=mark href=#fn-2><sup>2</sup></a>
Clients write into a public queue, which the broker reads from.
Responses are sent back through
dynamically created, single-use queues.
All communication is indirect, via SQS servers.
</p>
</dd>
</dl>

<aside class=footnote id=fn-1>
<sup>1</sup>
<a href="https://gitlab.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/-/merge_requests/50">AMP cache rendezvous</a>
</aside>

<aside class=note id=n-17>
<ul>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/26151">Snowflake rendezvous using Amazon SQS</a></li>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40323">Deploy new SQS rendezvous method</a></li>
<li><a href="https://gitlab.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/-/blob/38352b22ade217bd1372772b9cb69f8eff93e919/doc/rendezvous-with-sqs.md">Rendezvous with Amazon SQS</a></li>
</ul>
</aside>

<aside class=footnote id=fn-2>
<sup>2</sup>
<a href="https://gitlab.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/-/merge_requests/214">Implement SQS Rendezvous Method</a>
</aside>

<p id=p23>
Rendezvous is not unique to Snowflake.
Other examples of rendezvous are
the DEFIANCE Rendezvous Protocol&nbsp;<a href=#ref:Lincoln2012a class=cite>[<span class=number>20</span>&nbsp;§3]</a>,
the facilitator interaction in flash proxy&nbsp;<a href=#ref:Fifield2012a class=cite>[<span class=number>10</span>&nbsp;§3]</a>,
and the registration proxy in Conjure&nbsp;<a href=#ref:Frolov2019b class=cite>[<span class=number>13</span>&nbsp;§4.1]</a>.
A&nbsp;key property of Snowflake and the mentioned systems
is that their blocking resistance does not rely on preshared secret information.
Whatever information is needed to establish a circumvention session
is obtained dynamically at runtime.
This is in contrast to other systems in which,
before making a connection,
the client must acquire some secret,
such as an IP address or password,
through an out-of-band channel—and
blocking resistance depends on
keeping that information secret.
A&nbsp;corollary of the no-secret-information property
is that an adversary is
at no special disadvantage in attacking the system.
There is no out-of-band channel which real clients have access to
but the censor does not.
The censor may pose as a client,
download the software,
study its network connections—and
the system must maintain its blocking resistance despite this.
The disadvantage of a separate rendezvous step
is that it is one more thing to get right.
Both the main circumvention channel
and the rendezvous must resist blocking:
the combination is only as strong as the weaker of the&nbsp;two.
</p>

</section>

<section id=connection data-number=2.2>
<h3><a href=#connection><span class=number>2.2</span> Peer-to-peer connection establishment</a></h3>

<p id=p24>
After rendezvous,
the client and its assigned proxy connect to one another directly.
Even in the absence of censorship,
making a connection between two Internet peers is not trivial,
because of possible interference by NAT (network address translation) and firewalls.
Snowflake clients and proxies run in diverse networks
with varying NATs and ingress policies.
Fortunately for us,
WebRTC is designed with this use case in mind.
It&nbsp;has built-in support for NAT traversal in the form of
ICE (Interactive Connectivity Establishment)&nbsp;<a href=#ref:rfc8445 class=cite>[<span class=number>19</span>]</a>,
a procedure for testing combinations of peer addresses
until finding one that works.
ICE&nbsp;uses third-party
STUN (Session Traversal Utilities for NAT) servers&nbsp;<a href=#ref:rfc8489 class=cite>[<span class=number>28</span>]</a>
that, among other services,
let a host discover its own external IP addresses.
The first part of ICE happened at the beginning of rendezvous,
when the client and proxy contacted STUN servers to gather
external address candidates and included them in their respective
SDP offer and answer.
After rendezvous,
the peers try pairs of candidate addresses
until they are able to establish a connection.
</p>

<p id=p25>
There is no guarantee that two hosts will be able to
connect using the facilities of STUN alone.<a class=mark href=#n-21>&bull;</a>
Some combinations of address mapping and
filtering are simply incompatible.
In&nbsp;such a case,
ICE would normally fall back to relaying traffic through a
TURN (Traversal Using Relays around NAT) server&nbsp;<a href=#ref:rfc8656 class=cite>[<span class=number>30</span>]</a>,
a&nbsp;kind of UDP proxy.
A&nbsp;fallback to TURN would be problematic for Snowflake,
because the TURN servers themselves
would become targets of blocking.<a class=mark href=#n-18>&bull;</a>
But Snowflake has an advantage other WebRTC applications do not:
most applications want to connect <em>a particular</em> pair of peers,
whereas we are happy to connect a client to <em>any</em> proxy.
Snowflake clients and proxies self-assess their NAT type
and report it to the broker,
which then avoids making matches
that would require TURN.
</p>

<aside class=note id=n-21>
<a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/33666#note_2595319">Investigate Snowflake proxy failures</a>
</aside>

<aside class=note id=n-18>
<ul>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/25596">Configure TURN servers for the proxy and/or client</a></li>
<li><a href="https://datatracker.ietf.org/doc/html/rfc8445#section-5.1.1.2">RFC 8445</a>:
“…use of STUN and TURN servers may be unnecessary in certain networks and use of TURN servers may be expensive, so some deployments may elect not to use them.”</li>
</ul>
</aside>

<figure id=tab-nat-matching data-number=1>
<table>
<tr>
<td></td>
<th>No NAT</th>
<th>(EI, EI)</th>
<th>(EI, AO)</th>
<th>(EI, AP)</th>
<th>(ED, ED)</th>
<td></td>
<td></td>
</tr>
<tr>
<th>No NAT</th>
<td class=y>✓</td>
<td class=y>✓</td>
<td class=y>✓</td>
<td class=y>✓</td>
<td class=y>✓</td>
<td rowspan=3 class=leftbrace></td>
<td rowspan=3 class=leftbracelabel>Unrestricted proxy</td>
</tr>
<tr>
<th>(EI, EI)</th>
<td class=y>✓</td>
<td class=y>✓</td>
<td class=y>✓</td>
<td class=y>✓</td>
<td class=y>✓</td>
</tr>
<tr>
<th>(EI, AO)</th>
<td class=y>✓</td>
<td class=y>✓</td>
<td class=y>✓</td>
<td class=y>✓</td>
<td class=y>✓</td>
</tr>
<tr>
<th>(EI, AP)</th>
<td class=y>✓</td>
<td class=y>✓</td>
<td class=y>✓</td>
<td class=y>✓</td>
<td class=n>–</td>
<td rowspan=2 class=leftbrace></td>
<td rowspan=2 class=leftbracelabel>Restricted proxy</td>
</tr>
<tr>
<th>(ED, ED)</th>
<td class=y>✓</td>
<td class=y>✓</td>
<td class=y>✓</td>
<td class=n>–</td>
<td class=n>–</td>
</tr>
<tr>
<td></td>
<td colspan=4 class=upbrace></td>
<td class=upbrace></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td colspan=4 class=upbracelabel>Unrestricted client</td>
<td class=upbracelabel>Restricted<br>client</td>
<td></td>
<td></td>
</tr>
</table>
<figcaption>
<a href=#tab-nat-matching>Table&nbsp;1</a>:
Compatibility of NAT variations,
assuming the use of STUN only
(no&nbsp;fallback to TURN).
Variations are represented by (<var>mapping</var>,&nbsp;<var>filtering</var>) behavior pairs.
The table uses codes to indicate behaviors:
EI&nbsp;(endpoint-independent),
AO&nbsp;(address-dependent),
AP&nbsp;(address- and port-dependent), and
ED&nbsp;(either AO or&nbsp;AP).
The incompatible cases
are when one peer has ED mapping
and the other has ED mapping or
AP filtering.
Note the asymmetry in what NAT variations are considered “restricted”
in client and proxy.
</figcaption>
</figure>

<p id=p26>
<a href=#tab-nat-matching>Table&nbsp;1</a>
shows the compatibility of NAT variations.
A&nbsp;NAT variation is defined by a combination
of address mapping and filtering behaviors&nbsp;<a href=#ref:rfc5780 class=cite>[<span class=number>21</span>&nbsp;§3]</a><a class=mark href=#n-19>&bull;</a>.
Endpoint-dependent mapping
means that the address a local endpoint is translated to depends on
the remote endpoint’s IP address (and possibly port).
Endpoint-dependent filtering
means that incoming packets from a remote endpoint are
allowed only if outgoing packets have already been sent to that endpoint.
As&nbsp;the incompatible cases always involve endpoint-dependent address mapping
(sometimes called symmetric NAT),
we further categorize the variations into the two types
<em class=firstterm>unrestricted</em> (works with most other NATs) and
<em class=firstterm>restricted</em> (works only with more permissive NATs).
Unrestricted proxies may be matched with any client;
restricted proxies may be matched only with unrestricted clients.
The broker prefers to match unrestricted clients with restricted proxies<a class=mark href=#n-20>&bull;</a>,
in&nbsp;order to conserve unrestricted proxies
for the clients that need them.
Endpoint-dependent mapping is always considered restricted,
but the type of NATs with address- and port-dependent filtering differs
depending on the peer:
for proxies it is restricted, but
for clients it is unrestricted.
This is a heuristic
to conserve unrestricted proxies
for clients with endpoint-dependent NAT mapping.
Though it creates the potential for an incompatible match
between a client with an address- and port-dependent filter and a
proxy with endpoint-dependent mapping<a class=mark href=#n-22>&bull;</a>,
this case is rare in practice,
and if it happens,
a&nbsp;client can re-rendezvous and try again.
</p>

<aside class=note id=n-19>
<a href="https://datatracker.ietf.org/doc/html/rfc4787#section-4.1">RFC 4787 §4.1 “Address and Port Mapping”</a>
is a more direct citation for this,
but we did not have space for another bibliography entry.
</aside>

<aside class=note id=n-20>
<a href="https://gitlab.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/-/blob/9edaee65470a1483bbdbe984e5e15a885f1e95d2/broker/ipc.go#L236"><code>matchSnowflake</code></a>
</aside>

<aside class=note id=n-22>
<a href="https://gitlab.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/-/wikis/NAT-matching?version_id=dd1f328e2c9570eb252c43a053bdec0314c73345#fn-1-6791">“There is an edge case here…”</a>
</aside>

<p id=p27>
Clients use the NAT behavior discovery feature&nbsp;<a href=#ref:rfc5780 class=cite>[<span class=number>21</span>]</a> of STUN
to self-assess their NAT type.<a class=mark href=#n-23>&bull;</a>
Proxies cannot use the same technique,
because the necessary STUN features are not exposed
to JavaScript.
For proxies,
we adapt a technique from MassBrowser&nbsp;<a href=#ref:Nasr2020a class=cite>[<span class=number>24</span>&nbsp;§V-A]</a>
and run a centralized, always-on WebRTC testing peer
behind a simulated NAT with endpoint-dependent mapping.<a class=mark href=#fn-3><sup>3</sup></a>
If&nbsp;a proxy can connect to the testing peer,
its type is unrestricted;
otherwise it is restricted.
<!--
Clients and proxies retest their NAT type periodically,
to account for potential changes in their local networking environment.
-->
If&nbsp;a client or proxy is unable to determine its NAT type,
it&nbsp;reports the type “unknown,”
which the broker conservatively treats as restricted.
</p>

<aside class=note id=n-23>
<ul>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/34129">Use STUN to determine NAT behaviour of peers</a></li>
<li><a href="https://github.com/pion/stun/issues/8">Add utility to help user discover their NAT type</a></li>
</ul>
</aside>

<aside class=footnote id=fn-3>
<sup>3</sup>
<a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40013">Have a remote probe service to test snowflake proxy NAT compatability</a>
</aside>

<figure id=fig-proxy-nat-type data-number=3>
<picture>
<source srcset=proxy-nat-type.svg type="image/svg+xml" width=1000 height=375>
<img src=proxy-nat-type.png width=1000 height=375 alt="
Line graph showing the relative proportion of
“Restricted”, “Unknown”, “Unrestricted”, and “Untested”
proxy NAT types from July 2021 to March 2024.
The latest quantities are about
78,000 for Restricted,
52,000 for Unknown,
2,600 for Unrestricted, and
600 for Untested.
">
</picture>
<figcaption>
<a href=#fig-proxy-nat-type>Figure&nbsp;3</a>:
Proxy NAT types, in unique IP addresses per day.
The places in <time>2021</time> and <time>2022</time>
where “unknown” displaced other types
were caused by operational problems with
the NAT type testing peer.<a class=mark href=#n-24>&bull;</a>
</figcaption>
</figure>

<aside class=note id=n-24>
<ul>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40071">Increase of ‘unknown’ NAT assignments by probetest since <time>2021-10-25</time></a></li>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40147">Move snowflake-broker to a systemd based setup</a></li>
</ul>
</aside>

<p id=p28>
Unrestricted proxies are
a relatively small fraction of the proxy population,
as <a href=#fig-proxy-nat-type>Figure&nbsp;3</a> shows.
In&nbsp;absolute number, though, there are enough
for restricted clients at current levels of use.
The broker counts the number of unmatched (<var>U</var>)
and matched (<var>M</var>) client rendezvous requests per day.
If&nbsp;we assume that clients attempt rendezvous repeatedly until getting a match,
then the number of attempts per success is (<var>U</var>&nbsp;+&nbsp;<var>M</var>)&thinsp;/&thinsp;<var>M</var>.
Under this assumption, as&nbsp;of <time datetime=2024-03>March 2024</time>,
the average client needs 1.01 rendezvous attempts
to find a compatible proxy.<a class=mark href=#calc-3>&bull;</a>
</p>

<aside class=calc id=calc-3>
<details>
<summary>Calculation</summary>
<pre><samp>&gt; <kbd>library(tidyverse)</kbd>
&gt; <kbd>read_csv("figures/proxies/client-match.csv") %&gt;%
    filter(date &lt; "2024-03-01") %&gt;%
    mutate(
      attempts_per_success = (matched_count + unrestricted_denied_count + restricted_denied_count) / matched_count,
    ) %&gt;%
    group_by(month = format(date, "%Y-%m")) %&gt;%
    summarize(
      mean_attempts_per_success = mean(attempts_per_success),
        sd_attempts_per_success =   sd(attempts_per_success),
      .groups = "drop"
    ) %&gt;% tail(10)</kbd>
# A tibble: 10 × 3
   month   mean_attempts_per_success sd_attempts_per_success
   &lt;chr&gt;                       &lt;dbl&gt;                   &lt;dbl&gt;
 1 2023-05                      1.23                 0.114
 2 2023-06                      1.23                 0.0734
 3 2023-07                      1.07                 0.0498
 4 2023-08                      1.02                 0.0568
 5 2023-09                      1.00                 0.0148
 6 2023-10                      1.01                 0.0137
 7 2023-11                      1.00                 0.00499
 8 2023-12                      1.00                 0.0121
 9 2024-01                      1.01                 0.0168
10 2024-02                      1.00                 0.0170
</samp></pre>
</details>
</aside>

<p id=p29>
As&nbsp;the proxy negotiates the WebRTC connection with its client,
it&nbsp;also<a class=mark href=#n-25>&bull;</a> connects to the bridge using WebSocket&nbsp;<a href=#ref:rfc6455 class=cite>[<span class=number>23</span>]</a>.
Unlike the client connection, the bridge connection
presents no challenges:
it’s just HTTPS to an open port on a server.
The choice of WebSocket for this link is arbitrary,
and another protocol might be substituted in its place.
It&nbsp;does not need to be blocking-resistant
(because we are already outside the censor’s zone of control),
it&nbsp;only needs to be available to JavaScript code in web browsers.
</p>

<aside class=note id=n-25>
<a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40228">perf: proxy: don’t wait for WebRTC to establish before connecting to server</a>
</aside>

</section>

<section id=data-transfer data-number=2.3>
<h3><a href=#data-transfer><span class=number>2.3</span> Data transfer</a></h3>

<p id=p30>
No&nbsp;complicated processing occurs at the proxy.
The main value of a Snowflake proxy is its IP address:
it&nbsp;gives the client a peer to connect to that is not on the censor’s address blocklist.
Having provided that,
the proxy assumes a role of data transfer,
copying data upstream from client to bridge
and downstream from bridge to client.
</p>

<p id=p31>
Snowflake uses a stack of nested protocol layers.
<a href=#fig-protocol-layers>Figure&nbsp;4</a>
shows the stack for the link between the client and the proxy.
This is the link that uses WebRTC,
the one that is exposed to the censor.
The stack for the proxy–bridge link is the same,
but with WebSocket replacing
WebRTC in the outermost layer.
Layers at the top of the diagram are “outer,” closer to the network;
ones at the bottom are “inner,” closer to the user.
</p>

<figure id=fig-protocol-layers data-number=4>
<table>
<tr>
<td>UDP</td>
<td rowspan=3 class=leftbrace>
<td rowspan=3 class=leftbracelabel>WebRTC<br>data channel</td>
<td rowspan=3 class=leftbrace>
<td rowspan=3 class=leftbracelabel>ephemeral, per proxy</td>
</tr>
<tr>
<td>DTLS</td>
</tr>
<tr>
<td>SCTP</td>
</tr>
<tr>
<td>KCP</td>
<td rowspan=2 class=leftbrace>
<td rowspan=2 class=leftbracelabel>Turbo Tunnel</td>
<td rowspan=3 class=leftbrace>
<td rowspan=3 class=leftbracelabel>persistent, per session</td>
</tr>
<tr>
<td>smux</td>
</tr>
<tr>
<td colspan=3>Tor protocol</td>
</tr>
<tr>
<td colspan=5>application streams</td>
</tr>
</table>
<figcaption>
<a href=#fig-protocol-layers>Figure&nbsp;4</a>:
The protocol stack for the client–proxy link.
</figcaption>
</figure>

<p id=p32>
Each layer serves a different purpose.
The layers marked “ephemeral” are replaced
at every proxy switchover.
These outer layers form the “carrier”
over which the more stateful inner layers are transported.
The layers marked “persistent” are instantiated just once
per circumvention session and outlive any single proxy.
They maintain end-to-end state
and present an abstraction of a single long-lived tunnel.
This virtual tunnel then transports user application traffic
such as web browsing and messaging.
</p>

<p id=p33>
The point-to-point link between a client and its proxy is
a WebRTC data channel&nbsp;<a href=#ref:rfc8831 class=cite>[<span class=number>18</span>]</a>.
Data channels let two WebRTC peers
exchange arbitrary binary messages.<a class=mark href=#n-26>&bull;</a>
A&nbsp;data channel is itself a composition of three protocol layers:
UDP for network transport,
DTLS (Datagram TLS)
for confidentiality and integrity, and
SCTP (Stream Control Transmission Protocol)
for delimiting message boundaries
and other features like congestion control.
The peers authenticate each other
at the DTLS layer using certificate fingerprints
that were exchanged during rendezvous&nbsp;<a href=#ref:rfc8842 class=cite>[<span class=number>17</span>&nbsp;§5.1]</a>.
</p>

<aside class=note id=n-26>
<p id=p34>
Not going to get into how we currently use reliable, ordered (TCP-like) data
channels, but plan to switch to unreliable, unordered (UDP-like) data
channels, a better fit for the underlying datagram-oriented Turbo Tunnel
layer.
</p>
<ul>
<li><a href="https://gitlab.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/-/merge_requests/109">turn off reliable mode for WebRTC DataChannel</a></li>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40251#note_2891751">“Snowflake is currently using network resource in a so suboptimal way…”</a></li>
</ul>
</aside>

<p id=p35>
Data channels are well-suited to the circumvention use case.
But data channels are not the only option
in WebRTC:
there are also <em class=firstterm>media streams</em>,
meant for real-time audio and video.
Which of these options is used is an externally observable feature,
and may therefore become a fingerprinting vector.
We&nbsp;will consider this topic further in <a href=#fingerprinting>Section&nbsp;3</a>.
</p>

<p id=p36>
A&nbsp;proxy maintains two connections for each client it is currently serving:
a&nbsp;WebRTC connection to the client and a WebSocket connection to the bridge.
Data received from the client over WebRTC
is copied to the bridge over WebSocket,
and vice versa.
Although this pair of connections
effectively connects the client to the bridge,
it&nbsp;alone is not enough for usable circumvention,
because Snowflake proxies do not last forever.
When a proxy goes away,
its WebRTC and WebSocket connections go with&nbsp;it.
Without additional consideration,
the loss of a proxy would mean the end
of a client’s circumvention session.
What is needed is a separate notion of session state,
independent of the current proxy
and its data channel.
</p>

<p id=p37>
We&nbsp;adopt the
Turbo Tunnel design pattern&nbsp;<a href=#ref:Fifield2020a class=cite>[<span class=number>8</span>]</a>
and insert a userspace
session and reliability protocol
between the ephemeral “carrier” protocols
and the client’s application streams.<a class=mark href=#fn-4><sup>4</sup></a>
This inner protocol attaches sequence and acknowledgement numbers
to the pieces of data that pass through the tunnel.
After a temporary break in proxy connectivity,
the client and bridge first retransmit whatever data has not been acknowledged
by the other side,
then carry on as normal with new data,
with no duplication or gaps.
How this works, concretely,
is&nbsp;the client chooses a random session identifier string
at the beginning of its session,
and sends it as a preamble every time it
connects through a new proxy.
When the bridge accepts a WebSocket connection,
it&nbsp;inspects the preamble to find the client’s session identifier string,
which it uses to index a table of session state information.
If&nbsp;the session does not yet exist,
the bridge creates&nbsp;one;
otherwise it resumes an existing session
(starting by retransmitting any unacknowledged data).
If&nbsp;a client’s proxy disappears
in the middle of a long download, for example,
there may be a pause while Snowflake
does another rendezvous to acquire a fresh proxy,
but after that, the download continues uninterrupted.
</p>

<aside class=footnote id=fn-4>
<sup>4</sup>
<a href="https://lists.torproject.org/pipermail/anti-censorship-team/2020-February/000059.html">Turbo Tunnel in Snowflake</a>
</aside>

<p id=p38>
For the inner session layer we use a combination of
KCP&nbsp;<a href=#ref:kcp class=cite>[<span class=number>33</span>]</a> and
smux&nbsp;<a href=#ref:smux class=cite>[<span class=number>43</span>]</a>.
KCP provides reliability and retransmission,
and smux detects and terminates timed-out streams.
Other userspace protocols, for example QUIC or TCP,
could be used more or less equivalently for this purpose.
We&nbsp;prototyped successfully with both QUIC and KCP/<wbr>smux
before settling on the latter.
The main considerations that influenced our decision
were familiarity and ease of maintenance.
</p>

<p id=p39>
One more protocol layer is needed
before sending user application data through the tunnel:
an&nbsp;end-to-end secure channel between the client and the bridge,
using keys unknown to the proxy.
The inner session layer does not itself provide security,
and the DTLS of the data channel is only hop-by-hop,
not end-to-end.
The purpose of this additional secure channel is
to prevent proxies from inspecting or tampering with the traffic
they carry.
Nothing special is needed here; for example,
TLS, or any VPN protocol,
would work fine.
Our deployment uses the Tor protocol as this secure channel.
After removing the WebSocket and Turbo Tunnel layers,
the bridge feeds the data it receives into a local Tor bridge,
which routes the stream into the Tor network
and eventually to its destination.
Tor, of course, has privacy advantages
that are not, strictly speaking, necessary for circumvention,
but are nevertheless nice to have,
such as that not even the Snowflake bridge
is trusted to know the contents or destinations of client streams.
But Tor also has drawbacks,
which we will comment on in
<a href=#multi-bridge>Section&nbsp;4.4</a>
and
<a href=#future>Section&nbsp;6</a>.
</p>

<p id=p40>
Snowflake may be seen as an instance of the
“untrusted messengers” model of Feamster et&nbsp;al.&nbsp;<a href=#ref:Feamster2003a class=cite>[<span class=number>7</span>&nbsp;§3]</a>.
Their <em class=firstterm>messengers</em> correspond to our <em class=firstterm>proxies</em>;
their <em class=firstterm>portal</em> is our <em class=firstterm>bridge</em>.
Proxies are trusted to deliver the client’s traffic to the bridge,
but do not themselves connect to the destination, or&nbsp;even know what it&nbsp;is.
An&nbsp;inner layer of cryptography protects the client’s traffic
from observation and manipulation by malicious proxies.
The protection goes in the other direction as well:
because proxies are programmed to connect only to a Snowflake bridge,
and they never process anything but ciphertext,
a&nbsp;malicious client cannot cause a proxy to misbehave
or have its actions attributed to the proxy.
Without this mutual guarantee of safety,
it&nbsp;would be too risky to associate a client and proxy
who have no preexisting trust relationship.
</p>

</section>

</section>

<section id=fingerprinting data-number=3>
<h2><a href=#fingerprinting><span class=number>3</span> Protocol fingerprinting</a></h2>

<p id=p41>
Snowflake’s main focus is the “address blocking” side of circumvention,
but the “content blocking” side matters too.
The goal, as&nbsp;always, is to make circumvention traffic
hard to distinguish from traffic the censor cares not to block.
Design decisions in Snowflake—the use of WebRTC,
and the requirement to run proxies in browsers—mean
that Snowflake can, at&nbsp;best, only blend in with other WebRTC traffic.
But even within that scope,
there are variations in <em>how</em>
WebRTC is implemented and used,
which, if&nbsp;not carefully considered, might enable a censor
to selectively block only Snowflake,
leaving other uses of WebRTC undisturbed.<a class=mark href=#n-27>&bull;</a>
Unfortunately for the circumvention developer,
the richness of WebRTC protocols
creates a large attack surface for fingerprinting.
And then, there are fingerprinting considerations beyond WebRTC.
</p>

<aside class=note id=n-27>
<a href="https://gitlab.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/-/wikis/Fingerprinting">Fingerprinting</a>:
“Page to keep notes about the fingerprintability of WebRTC”
</aside>

<p id=p42>
The most prevalent implementations of WebRTC are in web browsers.
Snowflake originally used a WebRTC library extracted from Chromium<a class=mark href=#fn-5><sup>5</sup></a>,
but that proved to be difficult to maintain
and build for multiple platforms.
Since&nbsp;2019, Snowflake uses the Pion&nbsp;<a href=#ref:pion-webrtc class=cite>[<span class=number>29</span>]</a>
implementation of WebRTC.<a class=mark href=#fn-6><sup>6</sup></a>
Pion is not tied to any browser,
which is both good and bad.
The good is less development friction,
better memory safety
(Pion is written in Go, Chromium WebRTC in C++),
and a working relationship with upstream developers
to have fingerprinting changes made when needed.
The bad is that Pion’s protocol fingerprints
do not automatically match those of the mostly browser-originated
WebRTC that Snowflake aims to blend in with.
</p>

<aside class=footnote id=fn-5>
<sup>5</sup>
<a href="https://github.com/keroserene/go-webrtc">https://github.com/keroserene/go-webrtc</a>
</aside>

<aside class=footnote id=fn-6>
<sup>6</sup>
<a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/28942">Evaluate pion WebRTC</a>
</aside>

<p id=p43>
The following is a list of the main fingerprinting concerns in Snowflake and
what we have done to address them.
A&nbsp;fingerprinting vulnerability
does not automatically disqualify a circumvention system:
it&nbsp;depends on whether the vulnerability can be fixed
without changing the basic nature of the system.
The important thing is to have solid fundamentals:
minor flaws may be patched up as needed.
</p>

<dl>

<dt id=p44>Selection of STUN servers</dt>
<dd>
<p>
The use of STUN with WebRTC is common,
but the choice of what STUN servers to use is up to the application.
Running dedicated STUN servers for Snowflake would not work,
because a censor would experience no collateral harm in
blocking them.
Our deployment uses a pool of public STUN servers
that are used for purposes other than circumvention.
The client chooses a random subset
for each new session.
<!--
I thought about using stun.l.google.com as an example here.
As of 2024-01-31, stun.l.google.com seems to work in China.
It was DNS-blocked on 2022-10-01, but must have been unblocked since.
https://github.com/net4people/bbs/issues/128#issuecomment-1920113565
-->
</p>
</dd>

<dt id=p45>Format of STUN messages</dt>
<dd>
<p>
STUN is most often deployed over plaintext UDP,
which leaves the contents of messages open to inspection.
STUN messages consist of a fixed header
followed by a list of
attributes&nbsp;<a href=#ref:rfc8489 class=cite>[<span class=number>28</span>&nbsp;§5]</a>.
What attributes appear,
and their order,
depends on the STUN implementation
and how the application uses it.
</p>

<p id=p46>
We have not done anything particular
to disguise STUN messages.
Though UDP is the most common,
STUN specifies other transports,
including encrypted ones like DTLS.
The alternative transports may be options for Snowflake in the future—of&nbsp;course,
only if they are commonly used enough not to
stick out in themselves.<a class=mark href=#n-28>&bull;</a>
</p>
</dd>

<dt id=p47>Rendezvous</dt>
<dd>
<p>
Because the rendezvous methods of
<a href=#rendezvous>Section&nbsp;2.1</a>
are modular,
each one needs a separate justification
as to why it should be difficult to block.
Each method must also be implemented in a way
that does not expose accidental distinguishers.
For example, the domain fronting, AMP cache, and SQS rendezvous methods
use HTTPS,
which means TLS fingerprinting is a concern&nbsp;<a href=#ref:Fifield2015a class=cite>[<span class=number>11</span>&nbsp;§5.1]</a>.
</p>

<p id=p48>
Snowflake, like many circumvention systems,
uses the uTLS package&nbsp;<a href=#ref:Frolov2019a class=cite>[<span class=number>14</span>&nbsp;§VII]</a>
to get a client TLS fingerprint that is randomized or that imitates common browsers.
<a href=#block-ir>Section&nbsp;5.2</a> has an account of when
domain fronting rendezvous was briefly blocked in Iran,
because we were slow in activating uTLS.
</p>
</dd>

<dt id=p49>DTLS</dt>
<dd>
<p>
The outermost layer of a WebRTC data connection,
directly exposed to a censor,
is&nbsp;DTLS over UDP.
DTLS is an adaptation of TLS&nbsp;<a href=#ref:rfc9147 class=cite>[<span class=number>32</span>&nbsp;§1]</a> to the datagram setting,
and therefore shares the fingerprinting concerns of TLS&nbsp;<a href=#ref:Frolov2019a class=cite>[<span class=number>14</span>]</a>.
</p>

<p id=p50>
Owing to practical considerations,
Snowflake’s defenses to DTLS fingerprinting are not very robust,
and are reactive rather than proactive.
In&nbsp;the realm of TLS one may use uTLS,
but there is as yet no equivalent for DTLS.
The present way of altering DTLS fingerprints in Snowflake
is to submit a patch to Pion
when a feature used for fingerprinting is identified.<a class=mark href=#n-29>&bull;</a>
<a href=#block-ru>Section&nbsp;5.1</a> documents how this has happened twice,
in response to blocking in Russia.
</p>
</dd>

<dt id=p51>Data channel or media stream</dt>
<dd>
<p>
Along with data channels, WebRTC offers <em class=firstterm>media streams</em>,
which transmit encoded audio and video.
Though both data channels and media streams are encrypted,
they are externally distinguishable
because they use different encryption containers.
Data channels use DTLS,
while media streams use DTLS-SRTP;
that is, the Secure Real-Time Transport Protocol
with a DTLS key exchange&nbsp;<a href=#ref:rfc8827 class=cite>[<span class=number>31</span>&nbsp;§4.3]</a>.
</p>

<p id=p52>
Data channels are a closer match to Snowflake’s communication model:
media streams are meant for audio and video,
not arbitrary binary messages.
But the use of data channels could become
a fingerprinting feature if other WebRTC applications mainly use media streams.
Should it become necessary,
it&nbsp;would likely be possible to adapt Snowflake
to use media streams rather than data channels,
either by modulating data into an
audio or video signal in the manner&nbsp;of, say,
Stegozoa&nbsp;<a href=#ref:Figueira2022a class=cite>[<span class=number>12</span>&nbsp;§3.3]</a>,
or by replacing the encoded data inside SRTP packets,
as in Protozoa&nbsp;<a href=#ref:Barradas2020a class=cite>[<span class=number>2</span>&nbsp;§4.4]</a>
or TorKameleon&nbsp;<a href=#ref:Vilalonga2023a class=cite>[<span class=number>40</span>&nbsp;§III-D]</a>.
</p>
</dd>

</dl>

<aside class=note id=n-28>
<a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40240">Investigate if STUN over TCP/TLS is beneficial to us</a>
</aside>

<aside class=note id=n-29>
<p id=p53>
Fingerprinting changes upstreamed to Pion:
</p>
<ul>
<li>IP addresses as SNI values
<ul>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40014#note_2764715">https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40014#note_2764715</a></li>
<li><a href="https://github.com/pion/dtls/issues/406">https://github.com/pion/dtls/issues/406</a></li>
<li><a href="https://github.com/pion/dtls/pull/407">https://github.com/pion/dtls/pull/407</a></li>
</ul>
</li>
<li>supported_groups in Server Hello
<ul>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40014#note_2765074">https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40014#note_2765074</a></li>
<li><a href="https://github.com/pion/dtls/issues/409">https://github.com/pion/dtls/issues/409</a></li>
<li><a href="https://github.com/pion/dtls/pull/410">https://github.com/pion/dtls/pull/410</a></li>
</ul>
</li>
<li>Server sending Hello Verify Request
<ul>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40014#note_2764715">https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40014#note_2764715</a></li>
<li><a href="https://gitlab.torproject.org/tpo/applications/tor-browser-build/-/merge_requests/637">https://gitlab.torproject.org/tpo/applications/tor-browser-build/-/merge_requests/637</a></li>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40249">https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40249</a></li>
<li><a href="https://github.com/pion/dtls/pull/513">https://github.com/pion/dtls/pull/513</a></li>
<li><a href="https://github.com/pion/webrtc/pull/2407">https://github.com/pion/webrtc/pull/2407</a></li>
</ul>
</li>
</ul>
<p id=p54>
Not fingerprinting but also upstreamed:
</p>
<ul>
<li>NAT behavior detection
<ul>
<li><a href="https://github.com/pion/stun/issues/8">https://github.com/pion/stun/issues/8</a></li>
<li><a href="https://github.com/pion/stun/pull/33">https://github.com/pion/stun/pull/33</a></li>
</ul>
</li>
</ul>
</aside>

<p id=p55>
Most research on detecting Snowflake to date
has focused on protocol fingerprinting.
Fifield and Gil Epner&nbsp;<a href=#ref:arxiv.1605.08805 class=cite>[<span class=number>9</span>]</a>
studied the network traffic of WebRTC applications,
with the goal of finding pitfalls that could affect Snowflake.
Frolov et&nbsp;al.&nbsp;<a href=#ref:Frolov2019a class=cite>[<span class=number>14</span>&nbsp;§V-C]</a>
observed that the undisguised TLS fingerprint
of Snowflake’s domain fronting rendezvous was distinctive,
and introduced the uTLS package
now used to protect&nbsp;it.
</p>

<p id=p56>
MacMillan et&nbsp;al.&nbsp;<a href=#ref:arxiv.2008.03254 class=cite>[<span class=number>22</span>]</a>
focused on the DTLS handshake,
comparing Snowflake to three other WebRTC applications.
They correctly anticipated features
of the Pion DTLS handshake
that would later be used
to block Snowflake in Russia;
see details in <a href=#block-ru>Section&nbsp;5.1</a>.
Holland et&nbsp;al.&nbsp;<a href=#ref:Holland2021a class=cite>[<span class=number>16</span>&nbsp;§5.3]</a>,
using the bits of UDP datagrams directly as features,
demonstrated approximately equal performance
on the same DTLS handshake data set.
Their automatically derived classifier assigned high feature importance
to packet length fields,
in&nbsp;fact doing well even without DTLS payload features.
</p>

<p id=p57>
Chen et&nbsp;al.&nbsp;<a href=#ref:Chen2023a class=cite>[<span class=number>4</span>]</a>
combined features
of rendezvous and DTLS
in order to reduce false positives.
Their classifier begins
by looking for DNS queries for
STUN servers and front domains commonly used by Snowflake clients.
They then apply a machine learning classifier
to features of a subsequent DTLS handshake.
The authors acknowledge that DTLS fingerprinting
is fragile, as&nbsp;the DTLS features are, in&nbsp;principle,
controllable by the application.
The DNS prefilter may perhaps be mitigated
by alternative rendezvous methods (<a href=#rendezvous>Section&nbsp;2.1</a>),
or&nbsp;by smarter selection of STUN servers.
</p>

<p id=p58>
Xie et&nbsp;al.&nbsp;<a href=#ref:Xie2023a class=cite>[<span class=number>42</span>]</a> trained a decision tree to
distinguish domain fronting rendezvous
from certain other HTTPS exchanges,
using
packet size, direction, latency, and bandwidth features.
Wails et&nbsp;al.&nbsp;<a href=#ref:Wails2024a class=cite>[<span class=number>41</span>]</a>
criticize past research on detecting circumvention systems,
saying that accuracy claims do not hold up
in light of the low base rates of circumvention traffic in practice.<a class=mark href=#n-30>&bull;</a>
They developed classifiers
for Snowflake and other circumvention protocols
that improved on the state of the art,
but found them still to be prohibitively imprecise at realistic base rates.<a class=mark href=#n-31>&bull;</a>
They propose reducing false positives by combining
multiple observations per IP address—classifying hosts,
not flows—and suggest that Snowflake’s lack of
fixed proxies mitigates against this enhancement.<a class=mark href=#n-32>&bull;</a>
</p>

<aside class=note id=n-30>
<span class=nobreak>§IV-D</span>:
“Despite the prima facie acceptable performance of these
classifiers … we argue that these results <em>do not</em> accurately
reflect a censor’s ability to detect obfs4 under realistic conditions.”
</aside>

<aside class=note id=n-31>
<span class=nobreak>§V-C</span>:
“While it is the case that deep learning improves performance,
the false positive rates are still prohibitively high to scale to
realistic base rates. Fig.&nbsp;5 plots Prec<sup><var>λ</var></sup> as a function of the base
rate <var>λ</var>. For more realistic base rates, such as <var>λ</var> &gt; 1&thinsp;×&thinsp;10<sup>6</sup>, the
precision attained by any of the classifiers is near-zero.”
</aside>

<aside class=note id=n-32>
<span class=nobreak>§VII</span>:
“One way to mitigate the effects of host-based analysis is to
design circumvention systems to use multiple ephemeral bridges
over time rather than a few long-term static bridges, similar
the design of Snowflake.”
</aside>

<p id=p59>
Related to protocol fingerprinting is <em class=firstterm>traffic analysis</em>:
classifying connections based on features like
packet lengths and transmission times,
which may differ, in a circumvention system,
from other uses of the cover protocol.
The best classifiers of Xie et&nbsp;al. and Wails et&nbsp;al. were of this type.
While traffic analysis attacks are worth thinking about,
we&nbsp;caution that academic audiences
have historically overestimated their importance.
Tschantz et&nbsp;al.&nbsp;<a href=#ref:Tschantz2016a class=cite>[<span class=number>36</span>&nbsp;§VII]</a> observed
that censors are sensitive to costs
and—particularly—false positives.
They claim (and our experience bears it out)
that censors prefer traffic classification rules
that are simple, precise, and deterministic,
and avoid ones that
require managing state,
are computationally expensive,
or&nbsp;have non-negligible false positive rates, like
those based on traffic analysis.
<!--
Traffic analysis attacks are hardly worth considering
until after taking care of the fundamentals
of endpoint and content blocking,
and even then, there is, as&nbsp;yet, little evidence of their being used.
-->
Nevertheless, we&nbsp;have tried to future-proof Snowflake in this respect:
the protocol inside the WebRTC data channel supports
shaping of transmission sizes and timing,
which ought to be sufficient to imitate the traffic fingerprint
of other WebRTC applications.<a class=mark href=#n-33>&bull;</a>
But the feature is currently unused.
</p>

<aside class=note id=n-33>
<a href="https://gitlab.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/-/blob/38352b22ade217bd1372772b9cb69f8eff93e919/common/encapsulation/encapsulation.go#L153"><code>encapsulation.WritePadding</code></a>
</aside>

</section>

<section id=experience data-number=4>
<h2><a href=#experience><span class=number>4</span> Experience</a></h2>

<p id=p60>
Snowflake has now been in operation for a few years.
In&nbsp;lieu of a forward-looking evaluation,
here we take a look back
at the history of its deployment
and reflect on the experience.
Fielding a new circumvention system offers
an opportunity to study experimentally
its uptake and performance.
In&nbsp;this section we discuss
the number of clients over time and the bandwidth they use,
the size and composition of the proxy pool,
the variability of proxy IP addresses,
and engineering considerations related to scaling.
We&nbsp;take up the topic of reactions by censors
in <a href=#block>Section&nbsp;5</a>.
</p>

<section id=clients data-number=4.1>
<h3><a href=#clients><span class=number>4.1</span> Client counts and bandwidth</a></h3>

<figure id=fig-client-counts data-number=5>
<picture>
<source srcset=users-global.svg type="image/svg+xml" width=2100 height=690>
<img src=users-global.png width=2100 height=690 alt="
Two line graphs with a shared horizontal time axis.
The upper graph, “Average concurrent clients,” ranges from 0 to 100,000.
The lower graph, “Gbit/s,” ranges from 0 to 4.
The time axis goes from July 2021 to March 2024.
Events from the text are marked.
2021-07-06: Tor Browser 10.5 includes Snowflake;
2021-12-01: Onset of Tor blocking in Russia;
2021-12-14: &amp; 2021-12-20: Tor Browser 11.5a1 and 11.0.3 alter DTLS fingerprint;
2022-02-24: Russian invasion of Ukraine;
2022-03-16: Bridge hardware upgrade;
2022-07-14: Tor Browser 11.5 automatic configuration;
2022-09-20: Protests in Iran;
2022-10-04: TLS fingerprint blocking in Iran;
2022-10-27 &amp; 2022-11-01: Tor Browser 11.5.6 and Orbot 16.6.3 fix TLS fingerprint;
2022-12-07: Tor Browser 12.0 adds a second bridge;
2023-01-16 – 2023-01-24: Domain fronting rendezvous temporarily blocked in Iran;
2024-02-09: Release of Orbot 17;
2024-03-01: Second malfunction in domain fronting rendezvous.
">
</picture>
<figcaption>
<a href=#fig-client-counts>Figure&nbsp;5</a>:
Estimated average concurrent Snowflake clients and consumed bandwidth by day.
The values at the far left end of the graph,
in&nbsp;early <time datetime=2021-07>July&nbsp;2021</time>, are about&nbsp;200 users<a class=mark href=#calc-4>&bull;</a>
and 2.7&nbsp;Mbit/s<a class=mark href=#calc-5>&bull;</a>.
</figcaption>
</figure>
<p id=p61>

<aside class=calc id=calc-4>
<details>
<summary>Calculation</summary>
<pre><samp>&gt; <kbd>library("tidyverse")</kbd>
&gt; <kbd>WANTED_FINGERPRINTS &lt;- c(
    "7659DA0F96B156C322FBFF3ACCC9B9DC01C27C73" = "snowman",
    "5481936581E23D2D178105D44DB6915AB06BFB7F" = "snowflake-01",
    "91DA221A149007D0FD9E5515F5786C3DD07E4BB0" = "snowflake-02"
  )</kbd>
&gt; <kbd>userstats &lt;- read_csv("figures/users/userstats-bridge-transport-multi.csv") %&gt;%
    filter(transport == "snowflake" &amp; fingerprint %in% names(WANTED_FINGERPRINTS)) %&gt;%
    mutate(users = users / (coverage / pmax(num_instances, coverage))) %&gt;%
    group_by(date, transport) %&gt;% summarize(users = sum(users, na.rm = TRUE), .groups = "drop")</kbd>
  # Ignoring two apparently anomalous spikes before 2021.
  # One on 2020-05-21 and 2020-05-22 (the day of the Turbo Tunnel release):
&gt; <kbd>filter(userstats, "2020-05-19" &lt;= date &amp; date &lt;= "2020-05-24")</kbd>
# A tibble: 6 x 3
  date       transport  users
  &lt;date&gt;     &lt;chr&gt;      &lt;dbl&gt;
1 2020-05-19 snowflake   9.16
2 2020-05-20 snowflake  14.7
3 2020-05-21 snowflake 133.
4 2020-05-22 snowflake 388.
5 2020-05-23 snowflake   7.9
6 2020-05-24 snowflake  13.9
  # One on 2020-06-25 and 2020-06-26 (not sure what this one is about):
&gt; <kbd>filter(userstats, "2020-06-23" &lt;= date &amp; date &lt;= "2020-06-28")</kbd>
# A tibble: 6 x 3
  date       transport users
  &lt;date&gt;     &lt;chr&gt;     &lt;dbl&gt;
1 2020-06-23 snowflake  17.0
2 2020-06-24 snowflake  20.2
3 2020-06-25 snowflake  71.7
4 2020-06-26 snowflake 211.
5 2020-06-27 snowflake  22.5
6 2020-06-28 snowflake  33.7
&gt; <kbd>filtered &lt;- filter(userstats, !(date %in% as.Date(c("2020-05-21", "2020-05-22", "2020-06-25", "2020-06-26"))))</kbd>
&gt; <kbd>filter(filtered, abs(date - as.Date("2021-07-01")) &lt; 3)</kbd>
# A tibble: 5 × 3
  date       transport users
  &lt;date&gt;     &lt;chr&gt;     &lt;dbl&gt;
1 2021-06-29 snowflake  278.
2 2021-06-30 snowflake  282.
3 2021-07-01 snowflake  262.
4 2021-07-02 snowflake  199.
5 2021-07-03 snowflake  197.
</samp></pre>
</details>
</aside>

<aside class=calc id=calc-5>
<details>
<summary>Calculation</summary>
<pre><samp>&gt; <kbd>library("tidyverse")</kbd>
&gt; <kbd>WANTED_FINGERPRINTS &lt;- c(
    "7659DA0F96B156C322FBFF3ACCC9B9DC01C27C73" = "snowman",
    "5481936581E23D2D178105D44DB6915AB06BFB7F" = "snowflake-01",
    "91DA221A149007D0FD9E5515F5786C3DD07E4BB0" = "snowflake-02"
  )</kbd>
&gt; <kbd>options(width = 200)</kbd>
&gt; <kbd>userstats &lt;- read_csv("figures/users/userstats-bridge-transport-multi.csv") %&gt;%
    filter(fingerprint %in% names(WANTED_FINGERPRINTS)) %&gt;%
    mutate(users = users / (coverage / pmax(num_instances, coverage)))</kbd>
&gt; <kbd>bandwidth &lt;- read_csv("figures/users/bandwidth-multi.csv") %&gt;%
    filter(fingerprint %in% names(WANTED_FINGERPRINTS)) %&gt;%
    filter(coverage &gt; 0) %&gt;%
    mutate(bytes = bytes / (coverage / pmax(num_instances, coverage))) %&gt;%
    pivot_wider(id_cols = c(date, fingerprint), names_from = c(type), values_from = c(bytes)) %&gt;%
    mutate(
      good_read = read - `dirreq-read`,
      good_write = write - `dirreq-write`,
      good_avg = (good_read + good_write) / 2,
      good_avg_bps = good_avg*8/86400,
    )</kbd>
&gt; <kbd>left_join(userstats, bandwidth, by = c("date", "fingerprint")) %&gt;%
    # Subtract out the pro-rated fraction of non-snowflake transports (basically negligible).
    group_by(date, fingerprint) %&gt;%
    mutate(across(c(read, write, `dirreq-read`, `dirreq-write`, good_read, good_write, good_avg), &amp;nbsp; .x * users / sum(users))) %&gt;%
    ungroup() %&gt;%
    filter(transport == "snowflake") %&gt;%
    filter("2021-06-28" &lt;= date &amp; date &lt; "2021-07-04") %&gt;%
    group_by(date) %&gt;%
    summarize(
      date = last(date),
      across(c(read, write, `dirreq-read`, `dirreq-write`, good_read, good_write, good_avg, good_avg_bps), sum, na.rm = TRUE)
    ) %&gt;%
    mutate(
      across(c(read, write, `dirreq-read`, `dirreq-write`, good_read, good_write, good_avg), scales::label_bytes(units = "auto_si", accuracy = 0.01)),
      across(c(good_avg_bps), scales::label_number(scale_cut = scales::cut_si("bit"), accuracy = 0.01)),
    ) %&gt;%
    arrange(date) %&gt;% tail()</kbd>
# A tibble: 6 × 9
  date       read     write    `dirreq-read` `dirreq-write` good_read good_write good_avg good_avg_bps
  &lt;date&gt;     &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;         &lt;chr&gt;          &lt;chr&gt;     &lt;chr&gt;      &lt;chr&gt;    &lt;chr&gt;
1 2021-06-28 43.69 GB 45.14 GB 414.49 MB     5.03 GB        43.28 GB  40.11 GB   41.69 GB 3.86 Mbit
2 2021-06-29 32.92 GB 34.41 GB 404.10 MB     4.92 GB        32.51 GB  29.49 GB   31.00 GB 2.87 Mbit
3 2021-06-30 32.20 GB 34.24 GB 419.36 MB     5.06 GB        31.79 GB  29.18 GB   30.48 GB 2.83 Mbit
4 2021-07-01 31.17 GB 32.60 GB 354.75 MB     4.25 GB        30.82 GB  28.35 GB   29.58 GB 2.74 Mbit
5 2021-07-02 27.72 GB 27.40 GB 178.13 MB     2.15 GB        27.54 GB  25.25 GB   26.40 GB 2.44 Mbit
6 2021-07-03 28.02 GB 27.92 GB 200.54 MB     2.45 GB        27.82 GB  25.47 GB   26.64 GB 2.47 Mbit
</samp></pre>
</details>
</aside>

<!--
Excerpts from https://gitlab.torproject.org/tpo/network-health/metrics/timeline:
|2017-01-24|||snowflake|Tor Browser 7.0a1 released, including Snowflake for GNU/Linux only.|[blog post](https://blog.torproject.org/blog/tor-browser-70a1-released)||
|2017-08-08|||snowflake|Tor Browser 7.5a4 released, including Snowflake for macOS.|[blog post](https://blog.torproject.org/blog/tor-browser-75a4-released) [issue](https://bugs.torproject.org/tpo/applications/tor-browser/22831)||
|2018-03-26 20:43:42|||snowflake|Release of Tor Browser 8.0a5. Improves snowflake client performance.|[blog post](https://blog.torproject.org/tor-browser-80a5-released) [ticket](https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/21312)||
|2019-10-01|||snowflake|Release of Tor Browser 9.0a7, the first release that has Snowflake for Windows.|[blog post](https://blog.torproject.org/new-release-tor-browser-90a7) [ticket](https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/25483)||
|2020-05-22 19:51:29|||snowflake|Release of Tor Browser 9.5a13, the first release with Turbo Tunnel session persistence features for Snowflake. There is a spike in estimated users on 2020-05-21 and 2020-05-22, which appears to be an artifact.|[blog post](https://blog.torproject.org/new-release-tor-browser-95a13) [ticket](https://bugs.torproject.org/tpo/applications/tor-browser/34043) [users graph](https://metrics.torproject.org/userstats-bridge-transport.html?start=2020-03-01&end=2020-08-01&transport=snowflake)||
|2020-06-02 18:09:48|||snowflake|Release of Tor Browser 10.0a1, the first release with Snowflake for Android.|[blog post](https://blog.torproject.org/new-release-tor-browser-100a1) [ticket](https://bugs.torproject.org/tpo/applications/tor-browser/30318)||
|2020-06-25|2020-06-25||snowflake|One- or two-day spike in estimated Snowflake users. It resembles the spike that occurred around the time of the Turbo Tunnel release of Tor Browser 9.5a13 on 2020-05-22.|[users graph](https://metrics.torproject.org/userstats-bridge-transport.html?start=2020-03-01&end=2020-08-01&transport=snowflake)|X|
|2020-08-19|||snowflake|Release of Tor Browser 10.0a5, which added the ability to do NAT behavior discovery to the Snowflake client.|[blog post](https://blog.torproject.org/new-release-tor-browser-100a5/) [issue](https://bugs.torproject.org/tpo/applications/tor-browser-build/40016)||
|2020-10-29|||snowflake|Release of Snowflake WebExtension 0.5.0, with a NAT type self-test.|[archive](https://archive.org/details/snowflake-webextension-0.5.0) [issue](https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40013)||
|2020-11-17|||snowflake|Release of Snowflake WebExtension 0.5.2, with a fix to the NAT type self-test.|[archive](https://archive.org/details/snowflake-webextension-0.5.2) [merge request](https://gitlab.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake-webext/-/merge_requests/9) [comment](https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40013#note_2716071)||
|2021-01-12|||snowflake|Release of Orbot 16.4.0-RC-1-tor-0.4.4.6, first release with Snowflake client support.|[release](https://github.com/guardianproject/orbot/releases/tag/16.4.0-RC-1-tor-0.4.4.6)||
|2021-02-23|||snowflake|Release of Orbot 16.4.1-BETA-2-tor.0.4.4.6, with experimental Snowflake proxy support.|[release](https://github.com/guardianproject/orbot/releases/tag/16.4.1-BETA-2-tor.0.4.4.6)||
|2021-07-06 16:56:37|||snowflake|Release of Tor Browser 10.5, first stable release that includes Snowflake.|[blog post](https://blog.torproject.org/new-release-tor-browser-105)||
|2021-12-01|ongoing|ru||Blocking of Tor directory authorities, relays, default obfs4 bridges, meek-azure, and Snowflake in some ISPs in Russia. There was a temporary cease of blocking for less than a day starting on 2021-12-08.|[NTC thread](https://ntc.party/t/ooni-reports-of-tor-blocking-in-certain-isps-since-2021-12-01/1477) [BBS thread](https://github.com/net4people/bbs/issues/97) [issue](https://bugs.torproject.org/tpo/community/support/40050) [blog post](https://blog.torproject.org/tor-censorship-in-russia/) [OONI report](https://ooni.org/post/2021-russia-blocks-tor/#blocking-of-the-tor-network)||
|2021-12-14|||snowflake|Release of Tor Browser 11.5a1, with an altered DTLS fingerprint in Snowflake to counteract blocking in Russia.|[blog post](https://blog.torproject.org/new-release-tor-browser-115a1/) [issue](https://bugs.torproject.org/tpo/applications/tor-browser-build/40393) [NTC post](https://ntc.party/t/ooni-reports-of-tor-blocking-in-certain-isps-since-2021-12-01/1477/59)||
|2021-12-20|||snowflake|Release of Tor Browser 11.0.3, with an altered DTLS fingerprint in Snowflake to counteract blocking in Russia.|[blog post](https://blog.torproject.org/new-release-tor-browser-1103/) [issue](https://bugs.torproject.org/tpo/applications/tor-browser-build/40393) [NTC post](https://ntc.party/t/ooni-reports-of-tor-blocking-in-certain-isps-since-2021-12-01/1477/59)||
|2022-01-25 17:41:00|||snowflake|Switched the snowflake bridge to a temporary load-balanced staging server. Debugged connection problems until 2022-01-25 18:47:00.|[issue](https://bugs.torproject.org/tpo/tpa/team/40598#note_2772287) [comment](https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40095#note_2772325) [post](https://forum.torproject.net/t/tor-relays-how-to-reduce-tor-cpu-load-on-a-single-bridge/1483/16) [comment](https://github.com/net4people/bbs/issues/103#issuecomment-1033067920)||
|2022-03-16 16:51:35|||snowflake|Moved Snowflake traffic to the interim bridge running instances flakey1–flakey8.|[comment](https://bugs.torproject.org/tpo/tpa/team/40664#note_2787624)||
|2022-05-06 12:14:51|||snowflake|Upgraded the network uplink of the Snowflake bridge from 1 Gbps to 10 Gbps.|[issue](https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40138)||
|2022-06-27|||snowflake|Deployed version 0.6.0 of the Snowflake WebExtension. The main feature added in this release was support for more than one bridge. It had a bug that caused it to stop reporting client IP addresses, which are used for metrics purposes by the bridge.|[archive](https://archive.org/details/snowflake-webextension-0.6.0) [merge request](https://gitlab.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake-webext/-/merge_requests/29) [issue](https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake-webext/82)||
|2022-07-14|||bridge|Release of Tor Browser 11.5, with a new feature of automatic censorship circumvention configuration.|[blog post](https://blog.torproject.org/new-release-tor-browser-115/)||
|2022-09-21|ongoing|ir||Protests and daily Internet shutdowns in Iran.|[OONI report](https://ooni.org/post/2022-iran-blocks-social-media-mahsa-amini-protests/) [BBS thread](https://github.com/net4people/bbs/issues/125)||
|2022-10-03 12:50:34|||snowflake|Deployment of Snowflake broker to reject proxies that do not support multiple bridges.|[issue](https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40193) [issue](https://bugs.torproject.org/tpo/anti-censorship/team/95)||
|2022-10-04 17:15:00|||snowflake|Snowflake rendezvous blocked by TLS fingerprint in Iran.|[issue](https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40207) [BBS thread](https://github.com/net4people/bbs/issues/131)||
|2022-10-12|||snowflake|Release of Tor Browser 11.5.4. Adds uTLS TLS camouflage support for Snowflake, making a manual configuration possible to circumvent recent TLS blocking in Iran.|[blog post](https://blog.torproject.org/new-release-tor-browser-1154/) [BBS comment](https://github.com/net4people/bbs/issues/131#issuecomment-1280391051)||
|2022-10-17 15:52:00||ir|snowflake|Enabled uTLS for Snowflake in Iran in the Circumvention Settings API, using the `hellochrome_auto` fingerprint.|[comment](https://bugs.torproject.org/tpo/anti-censorship/team/96#note_2844378) [merge request](https://gitlab.torproject.org/tpo/anti-censorship/rdsys-admin/-/merge_requests/6)||
|2022-10-20 15:16:00|||snowflake|Release of Orbot for Android 16.6.3-BETA-2-tor.0.4.7.10. Adds uTLS TLS camouflage support for Snowflake, making it possible to circumvent recent TLS blocking in Iran.|[release](https://github.com/guardianproject/orbot/releases/tag/16.6.3-BETA-2-tor.0.4.7.10) [announcement](https://github.com/net4people/bbs/issues/125#issuecomment-1285897627)||
|2022-10-27|||snowflake|Release of Tor Browser 11.5.6. Fixes the problem that prevented Snowflake from working in 11.5.5, and enables uTLS TLS camouflage support by default for Snowflake.|[blog post](https://blog.torproject.org/new-release-tor-browser-1156/) [issue](https://bugs.torproject.org/tpo/applications/tor-browser-build/40665)||
|2022-11-01||ir|snowflake|Orbot begins a gradual release rollout of version 16.6.3-RC-1-tor.0.4.7.10, which has TLS fingerprint changes to make Snowflake work in Iran again.|[release](https://github.com/guardianproject/orbot/releases/tag/16.6.3-RC-1-tor.0.4.7.10)||
|2022-12-01|||snowflake|Release of Tor Browser 12.0a5, the first release to contain both the snowflake-01 and snowflake-02 bridges.|[issue](https://bugs.torproject.org/tpo/applications/tor-browser-build/40674) [announcement](https://lists.torproject.org/pipermail/tor-announce/2022-December/000256.html) [BBS comment](https://github.com/net4people/bbs/issues/152#issuecomment-1336220171)||
|2022-12-07|||snowflake|Release of Tor Browser 12.0, the first stable release to contain both the snowflake-01 and snowflake-02 bridges.|[issue](https://bugs.torproject.org/tpo/applications/tor-browser-build/40674) [blog post](https://blog.torproject.org/new-release-tor-browser-120/) [BBS comment](https://github.com/net4people/bbs/issues/152#issuecomment-1342800169) [NTC comment](https://ntc.party/t/second-snowflake-bridge-available-for-testing/3445/2)||
|2023-01-16|2023-01-24|ir|moat snowflake|The domain name cdn.sstatic.net, which is used by Snowflake and Moat, is blocked in some ISPs in Iran.|[comment](https://bugs.torproject.org/tpo/anti-censorship/team/115#note_2873040)||
|2023-01-31|2023-02-01|ir|moat snowflake|The domain name cdn.sstatic.net, which is used by Snowflake and Moat, is again blocked in some ISPs in Iran.|[comment](https://bugs.torproject.org/tpo/anti-censorship/team/115#note_2876012)||
|2023-02-08|2023-02-13|ir|moat snowflake|The domain name cdn.sstatic.net, which is used by Snowflake and Moat, is again blocked in some ISPs in Iran.|[comment](https://bugs.torproject.org/tpo/anti-censorship/team/115#note_2883298) [OONI chart](https://explorer.ooni.org/chart/mat?probe_cc=IR&since=2023-01-23&until=2023-03-01&time_grain=day&axis_x=measurement_start_day&test_name=web_connectivity&domain=cdn.sstatic.net)||
|2023-02-15|||snowflake|Release of Tor Browser 12.0.3. Has a change to the Snowflake DTLS fingerprint (removes Hello Verify Request) to mitigate reported blocking in Russia.|[blog post](https://blog.torproject.org/new-release-tor-browser-1203/) [comment about Hello Verify Request](https://bugs.torproject.org/tpo/anti-censorship/censorship-analysis/40030#note_2823140) [Snowflake merge request](https://gitlab.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/-/merge_requests/134) [Tor Browser merge request](https://gitlab.torproject.org/tpo/applications/tor-browser-build/-/merge_requests/637)||
|2023-02-19|2023-02-19|ir|moat snowflake|The domain name cdn.sstatic.net, which is used by Snowflake and Moat, is again blocked in some ISPs in Iran.|[comment](https://bugs.torproject.org/tpo/anti-censorship/team/115#note_2883298) [OONI chart](https://explorer.ooni.org/chart/mat?probe_cc=IR&since=2023-01-23&until=2023-03-01&time_grain=day&axis_x=measurement_start_day&test_name=web_connectivity&domain=cdn.sstatic.net)||
|2023-02-22|2023-02-22|ir|moat snowflake|The domain name cdn.sstatic.net, which is used by Snowflake and Moat, is again blocked in some ISPs in Iran.|[comment](https://bugs.torproject.org/tpo/anti-censorship/team/115#note_2883298) [OONI chart](https://explorer.ooni.org/chart/mat?probe_cc=IR&since=2023-01-23&until=2023-03-01&time_grain=day&axis_x=measurement_start_day&test_name=web_connectivity&domain=cdn.sstatic.net)||
|2023-03-13 19:46:07|||snowflake|Restarted snowflake-02 bridge for a bugfix.|[comment](https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40262#note_2886032) [issue](https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40260)||
|2023-03-13 20:17:54|||snowflake|Restarted snowflake-01 bridge for a bugfix.|[comment](https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40262#note_2886041) [issue](https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40260)||
|2023-03-15|||snowflake|Release of Orbot for Android v17 BETA 2. First release of Orbot to include the snowflake-02 bridge along with the existing snowflake-01. Has a change to the Snowflake DTLS fingerprint (removes Hello Verify Request) to mitigate reported blocking in Russia.|[release](https://github.com/guardianproject/orbot/releases/tag/17.0.0-BETA-2-tor.0.4.7.11) [Orbot commit adding snowflake-02](https://github.com/guardianproject/orbot/commit/c3f6ee18f17770a5904ad19c3cd24b9c8dcb3885) [IPtProxy commit upgrading Snowflake](https://github.com/tladesignz/IPtProxy/commit/5d0654a6a1439c05d3ee52b2b351b5df1ff3f6dc)||
|2024-02-09||||Release of Orbot for Android 17.2.1-RC-1-tor-0.4.8.7, the first release of Orbot 17 available for all users.|[release](https://github.com/guardianproject/orbot/releases/tag/17.2.1-RC-1-tor-0.4.8.7)||
-->

<p id=p62>
As&nbsp;a consequence of our use of a Tor bridge
as the backend for the Snowflake bridge,
we&nbsp;can estimate client counts and bandwidth using
the privacy-preserving
techniques of Tor Metrics&nbsp;<a href=#ref:tor-reproducible-metrics class=cite>[<span class=number>35</span>]</a>.
Tor bridges publish daily summaries of statistics,
including client counts and bandwidth,
as&nbsp;well as an aggregate distribution of client countries
inferred from a local geolocation database.
<a href=#fig-client-counts>Figure&nbsp;5</a> shows the number of clients
and amount of bandwidth consumed since 2021.
The upper graph depicts not a count of unique clients,
but rather the <em>average number of concurrent clients</em> per day.<a class=mark href=#n-34>&bull;</a>
<!--
$ grep '^2022-02-04.*,snowflake,' figures/users/userstats-bridge-transport-multi.csv
2022-02-04,5481936581E23D2D178105D44DB6915AB06BFB7F,snowflake,10124.23,4.00,4.00
-->
For example, when the graph passes through 10,000 on <time>2022-02-04</time>,
it&nbsp;means there were, on&nbsp;average, 10,000 clients using Snowflake
at a given time on that day.
The number of users is estimated by counting the “directory requests”
that Tor clients make periodically.
The contribution of a client session depends on its duration,
not on how many temporary proxies it uses;
a&nbsp;client connected for two hours counts half as much
as one connected for four hours.
Bandwidth is computed as the
average of incoming and outgoing bytes
(which are approximately equal anyway),
after subtracting
bytes spent processing directory requests
(which are less than 1% of total bandwidth<a class=mark href=#calc-6>&bull;</a>).
</p>

<aside class=note id=n-34>
<a href="https://metrics.torproject.org/reproducible-metrics.html#users">“The result is an average number of concurrent users, estimated from data collected over a day. We can’t say how many distinct users there are.”</a>
</aside>

<aside class=calc id=calc-6>
<details>
<summary>Calculation</summary>
<pre><samp>2024-01-30,5481936581E23D2D178105D44DB6915AB06BFB7F,dirreq-read,9010514338.54,12.00,12.00
2024-01-30,5481936581E23D2D178105D44DB6915AB06BFB7F,dirreq-write,183779650063.64,12.00,12.00
2024-01-30,5481936581E23D2D178105D44DB6915AB06BFB7F,read,27658592171042.61,12.00,12.00
2024-01-30,5481936581E23D2D178105D44DB6915AB06BFB7F,write,27638803440777.79,12.00,12.00
2024-01-30,91DA221A149007D0FD9E5515F5786C3DD07E4BB0,dirreq-read,2878113136.53,12.00,12.00
2024-01-30,91DA221A149007D0FD9E5515F5786C3DD07E4BB0,dirreq-write,69434558541.69,12.00,12.00
2024-01-30,91DA221A149007D0FD9E5515F5786C3DD07E4BB0,read,9925612576857.30,12.00,12.00
2024-01-30,91DA221A149007D0FD9E5515F5786C3DD07E4BB0,write,9851906962576.33,12.00,12.00
&gt;&gt;&gt; <kbd>9010514338.54 / 27658592171042.61 * 100</kbd>
0.03257763187228898
&gt;&gt;&gt; <kbd>183779650063.64 / 27658592171042.61 * 100</kbd>
0.6644577168900507
&gt;&gt;&gt; <kbd>2878113136.53 / 9925612576857.30 * 100</kbd>
0.028996831321430473
&gt;&gt;&gt; <kbd>69434558541.69 / 9925612576857.30 * 100</kbd>
0.6995493527884072
</samp></pre>
</details>
</aside>

<p id=p63>
Snowflake shipped in the alpha release series of Tor Browser
for years before entering the stable series.
The first releases were
for GNU/Linux
in Tor Browser&nbsp;7.0a1 on <time>2017-01-24</time>&#x202f;<a class=mark href=#fn-7><sup>7</sup></a>
and for macOS
in Tor Browser&nbsp;7.5a4 on <time>2017-08-08</time>&#x202f;<a class=mark href=#fn-8><sup>8</sup></a>.
Here we encountered difficulties with
the Chromium-derived WebRTC library we had used
up to that point
that prevented us from making releases for other platforms.
We&nbsp;were able to resume making progress after switching to
Pion WebRTC&nbsp;<a href=#ref:pion-webrtc class=cite>[<span class=number>29</span>]</a> in&nbsp;2019.
Snowflake for Windows was released
in Tor Browser&nbsp;9.0a7 on <time>2019-10-01</time>&#x202f;<a class=mark href=#fn-9><sup>9</sup></a>,
and for Android in
Tor Browser&nbsp;10.0a1 on <time>2020-06-02</time>&#x202f;<a class=mark href=#fn-10><sup>10</sup></a>.
</p>

<aside class=footnote id=fn-7>
<sup>7</sup>
<ul>
<li><a href="https://bugs.torproject.org/tpo/applications/tor-browser/20735">Add snowflake pt to alpha linux builds</a></li>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/19001#note_2591210">First working bundles with Snowflake, for linux only</a></li>
</ul>
</aside>

<aside class=footnote id=fn-8>
<sup>8</sup>
<ul>
<li><a href="https://bugs.torproject.org/tpo/applications/tor-browser/22831">Merge Snowflake for mac</a></li>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/19001#note_2591242">mac reproducible build</a></li>
<li><a href="https://lists.torproject.org/pipermail/tbb-dev/2017-July/000579.html">Please check reproducibility of mac build with Snowflake (e084e83418)</a></li>
</ul>
</aside>

<aside class=footnote id=fn-9>
<sup>9</sup>
<a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/25483">Windows reproducible build of snowflake"</a>
</aside>

<aside class=footnote id=fn-10>
<sup>10</sup>
<ul>
<li><a href="https://bugs.torproject.org/tpo/applications/tor-browser/30318">Integrate snowflake into mobile Tor Browser alpha</a></li>
<li><a href="https://bugs.torproject.org/tpo/applications/tor-browser/28672">Android reproducible build of Snowflake</a></li>
</ul>
</aside>

<p id=p64>
Snowflake was then available
on every platform supported by Tor Browser,
but was not yet comfortably usable.
Two important parts were missing:
a&nbsp;lack of NAT type matching (<a href=#connection>Section&nbsp;2.2</a>)
meant that a client could not always connect to its assigned proxy;
and no persistent session state (<a href=#data-transfer>Section&nbsp;2.3</a>)
meant that even if a proxy connection were successful,
the client’s session would end once its first proxy disappeared.
For these reasons,
by&nbsp;early 2020,
the number of concurrent users
had not risen above&nbsp;40.<a class=mark href=#calc-7>&bull;</a>
The Turbo Tunnel session persistence feature
became available to users in Tor Browser&nbsp;9.5a13
on <time>2020-05-22</time>.<a class=mark href=#fn-11><sup>11</sup></a>
The client part of NAT behavior detection
was released with Tor Browser&nbsp;10.0a5 on <time>2020-08-19</time>&#x202f;<a class=mark href=#fn-12><sup>12</sup></a>,
and proxy support was added on <time>2020-11-17</time>&#x202f;<a class=mark href=#fn-13><sup>13</sup></a>.
With these changes, Snowflake became practical to use for daily browsing,
and the number of clients began to grow into&nbsp;2021.
</p>

<aside class=calc id=calc-7>
<details>
<summary>Calculation</summary>
<pre><samp>&gt; <kbd>filtered[which.max(filter(filtered, date &lt; "2020-05-21")$users), ]</kbd>
# A tibble: 1 x 3
  date       transport users
  &lt;date&gt;     &lt;chr&gt;     &lt;dbl&gt;
1 2020-04-01 snowflake  34.0
</samp></pre>
</details>
</aside>

<aside class=footnote id=fn-11>
<sup>11</sup>
<ul>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/33745">Merge a turbotunnel branch</a></li>
<li><a href="https://bugs.torproject.org/tpo/applications/tor-browser/34043">Update snowflake to persist sessions across proxies</a></li>
</ul>
</aside>

<aside class=footnote id=fn-12>
<sup>12</sup>
<ul>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/34129">Use STUN to determine NAT behaviour of peers</a></li>
<li><a href="https://bugs.torproject.org/tpo/applications/tor-browser-build/40016">Update snowflake version and prefs to do nat discovery at the client</a></li>
</ul>
</aside>

<aside class=footnote id=fn-13>
<sup>13</sup>
<ul>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40013">Have a remote probe service to test snowflake proxy NAT compatability</a></li>
<li><a href="https://gitlab.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake-webext/-/merge_requests/9">Wait for ice gathering to complete before probtest</a></li>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40013#note_2716071">“After merging snowflake-webext!9, this is finally working”</a></li>
<li><a href="https://archive.org/details/snowflake-webextension-0.5.2">https://archive.org/details/snowflake-webextension-0.5.2</a></li>
</ul>
</aside>

<p id=p65>
Snowflake’s growth began in earnest
when it became part of default installations.
Orbot, a mobile app that provides a VPN-like Tor proxy,
added a Snowflake client in version 16.4.0
on <time>2021-01-12</time>.<a class=mark href=#fn-14><sup>14</sup></a>
Snowflake graduated to Tor Browser’s stable series
in Tor Browser&nbsp;10.5
on <time>2021-07-06</time>&#x202f;<a class=mark href=#fn-15><sup>15</sup></a>,
becoming a third built-in circumvention option
alongside meek and obfs4.<a class=mark href=#n-35>&bull;</a>
This is the first event marked in <a href=#fig-client-counts>Figure&nbsp;5</a>.
Being in the stable release series meant Snowflake was
easily available to all Tor users,
not only a self-selected group of alpha testers.
The number of concurrent clients increased steadily
over the next five months,
reaching almost 2,000 by <time datetime=2021-12>December&nbsp;2021</time>.
</p>

<aside class=footnote id=fn-14>
<sup>14</sup>
<ul>
<li><a href="https://github.com/guardianproject/orbot/releases/tag/16.4.0-RC-1-tor-0.4.4.6">Orbot 16.4.0-RC-1-tor-0.4.4.6</a></li>
<!-- https://github.com/guardianproject/orbot/blob/a69f39bb37469e65730d0751519848ec29001959/CHANGELOG#L788 /** 16.4.0-RC-1-tor-0.4.4.6 / 12 January 2021 **/ -->
<li><a href="https://lists.mayfirst.org/pipermail/guardian-dev/2023-July/005704.html">First version of Orbot with Snowflake, 16.4.0 on 2021-01-12?</a></li>
</ul>
</aside>

<aside class=footnote id=fn-15>
<sup>15</sup>
<a href="https://blog.torproject.org/new-release-tor-browser-105">New Release: Tor Browser 10.5</a>
</aside>

<aside class=footnote id=n-35>
<a href="https://gitlab.torproject.org/tpo/applications/tor-browser-build/-/blob/tbb-10.5-build1/projects/tor-browser/Bundle-Data/PTConfigs/bridge_prefs.js">bridge_prefs.js</a>
</aside>

<p id=p66>
Censorship events may have the apparently contrary effects
of either decreasing or increasing usage
of a circumvention system.
Usage decreases
when the system itself succumbs to blocking;
but increases when other, less robust
systems are blocked,
and users become concentrated
onto the reduced number of systems that remain working.
Two censorship events,
one in Russia and one in Iran,
resulted in large increases in the number of Snowflake users.
</p>

<p id=p67>
On <time>2021-12-01</time>, some ISPs in Russia
instituted measures to block
most ways of accessing Tor,
including Snowflake&nbsp;<a href=#ref:ooni-2021-russia-blocks-tor class=cite>[<span class=number>44</span>]</a>.
The measures varied in effectiveness;
in&nbsp;the case of Snowflake,
blocking was triggered by a feature of the DTLS handshake,
which we were able to mitigate in new releases within a few weeks.<a class=mark href=#fn-16><sup>16</sup></a>
Over the next two months, the number of clients quadrupled;
by&nbsp;<time datetime=2022-05>May 2022</time>,
about 70% of Snowflake users were in Russia.<a class=mark href=#calc-8>&bull;</a>
The client count in Russia got an additional small boost
starting on <time>2022-07-14</time>,
when Tor Browser&nbsp;11.5 added a feature
to automatically enable circumvention options when needed.<a class=mark href=#fn-17><sup>17</sup></a>
We&nbsp;will look at Russia in more detail in <a href=#block-ru>Section&nbsp;5.1</a>.
</p>

<aside class=footnote id=fn-16>
<sup>16</sup>
<ul>
<li><a href="https://bugs.torproject.org/tpo/applications/tor-browser-build/40393">Point to a forked version of pion/dtls with fingerprinting fix</a></li>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40014#note_2765074">“All right, finally managed to circumvent the censorship.”</a></li>
<li><a href="https://blog.torproject.org/new-release-tor-browser-115a1/">New Alpha Release: Tor Browser 11.5a1 (Windows, macOS, Linux)</a></li>
<li><a href="https://blog.torproject.org/new-release-tor-browser-1103/">New Release: Tor Browser 11.0.3</a></li>
</ul>
</aside>

<aside class=calc id=calc-8>
<details>
<summary>Calculation</summary>
<pre><samp>&gt; <kbd>library("tidyverse")</kbd>
&gt; <kbd>WANTED_FINGERPRINTS &lt;- c(
    "7659DA0F96B156C322FBFF3ACCC9B9DC01C27C73" = "snowman",
    "5481936581E23D2D178105D44DB6915AB06BFB7F" = "snowflake-01",
    "91DA221A149007D0FD9E5515F5786C3DD07E4BB0" = "snowflake-02"
  )</kbd>
&gt; <kbd>userstats &lt;- read_csv("figures/users/userstats-bridge-combined-multi.csv") %&gt;%
    filter(transport == "snowflake" &amp; fingerprint %in% names(WANTED_FINGERPRINTS)) %&gt;%
    mutate(across(c(low, high), &amp;nbsp; .x / (coverage / pmax(num_instances, coverage)))) %&gt;%
    mutate(users = (low + high) / 2) %&gt;%
    # Combine the contributions of all bridges.
    group_by(date, transport, country) %&gt;% summarize(across(c(low, high, users), sum), .groups = "drop") %&gt;%
    # Apportion "??" to other countries (see figures/users/users-country.r).
    group_by(date, transport) %&gt;% mutate(across(c(low, high, users), &amp;nbsp; .x * sum(.x) / sum(ifelse(country == "??", 0, .x)))) %&gt;% ungroup() %&gt;% filter(country != "??")</kbd>
&gt; <kbd>userstats %&gt;% filter(date == "2022-05-20") %&gt;% arrange(desc(users)) %&gt;%
    mutate(percent = users / sum(users) * 100) %&gt;% head()</kbd>
# A tibble: 6 x 7
  date       transport country   low  high users percent
  &lt;date&gt;     &lt;chr&gt;     &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;
1 2022-05-20 snowflake ru      9311. 9311. 9311.   70.4
2 2022-05-20 snowflake us      1108. 1109. 1109.    8.38
3 2022-05-20 snowflake cn       533.  535.  534.    4.04
4 2022-05-20 snowflake de       256.  258.  257.    1.94
5 2022-05-20 snowflake by       200.  202.  201.    1.52
6 2022-05-20 snowflake gb       184.  186.  185.    1.40
</samp></pre>
</details>
</aside>

<aside class=footnote id=fn-17>
<sup>17</sup>
<ul>
<li><a href="https://blog.torproject.org/new-release-tor-browser-115/">New Release: Tor Browser 11.5</a></li>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake-webext/82#note_2891387">Graph showing boost going mostly to Russia: https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake-webext/82#note_2891387</a></li>
</ul>
</aside>

<p id=p68>
In&nbsp;reaction to protests that began on <time>2022-09-16</time>
after the death of Mahsa Amini,
the government of Iran imposed network shutdowns
and additional blocking,
severe even by the standards of a country already notorious
for censorship&nbsp;<a href=#ref:ooni-2022-iran-blocks-social-media-mahsa-amini-protests class=cite>[<span class=number>3</span>]</a>.
Users turned to the circumvention systems
that continued working despite the new restrictions,
Snowflake among them.
Adoption was rapid:
on&nbsp;<time>2022-09-20</time>, Iran accounted for 1% of Snowflake users;
by <time>2022-09-24</time> it was&nbsp;67%.<a class=mark href=#calc-9>&bull;</a>
The sudden influx of users had us scrambling for a few days
to implement performance improvements.<a class=mark href=#n-36>&bull;</a>
Two weeks later, on <time>2022-10-04</time>,
usage dropped almost as quickly as it had risen—the
cause was the blocking, in&nbsp;Iran, of&nbsp;a TLS fingerprint
used by the Snowflake client.<a class=mark href=#fn-18><sup>18</sup></a>
After we released fixes for the TLS fingerprinting issue,
the client count began to recover.
But in our haste to deploy performance optimizations in <time datetime=2022-09>September</time>,
we&nbsp;inadvertently introduced a bug that actually harmed performance,
becoming more severe at higher client counts.<a class=mark href=#fn-19><sup>19</sup></a>
This dragged the count down again,
until we fixed the bug in <time datetime=2023-03>mid-March 2023</time>.<a class=mark href=#fn-20><sup>20</sup></a>
(Umayya et&nbsp;al. happened to be doing performance tests of Snowflake
and other circumvention systems
at this time&nbsp;<a href=#ref:Umayya2023a class=cite>[<span class=number>37</span>&nbsp;§4.6]</a>—their results
independently confirm the reduced reliability of Snowflake
before the performance bug was fixed.)<a class=mark href=#n-77>&bull;</a>
We&nbsp;will say more about Iran
in <a href=#block-ir>Section&nbsp;5.2</a>.
</p>

<aside class=calc id=calc-9>
<details>
<summary>Calculation</summary>
<pre><samp>&gt; <kbd>library("tidyverse")</kbd>
&gt; <kbd>WANTED_FINGERPRINTS &lt;- c(
    "7659DA0F96B156C322FBFF3ACCC9B9DC01C27C73" = "snowman",
    "5481936581E23D2D178105D44DB6915AB06BFB7F" = "snowflake-01",
    "91DA221A149007D0FD9E5515F5786C3DD07E4BB0" = "snowflake-02"
  )</kbd>
&gt; <kbd>userstats &lt;- read_csv("figures/users/userstats-bridge-combined-multi.csv") %&gt;%
    filter(transport == "snowflake" &amp; fingerprint %in% names(WANTED_FINGERPRINTS)) %&gt;%
    mutate(across(c(low, high), &amp;nbsp; .x / (coverage / pmax(num_instances, coverage)))) %&gt;%
    mutate(users = (low + high) / 2) %&gt;%
    # Combine the contributions of all bridges.
    group_by(date, transport, country) %&gt;% summarize(across(c(low, high, users), sum), .groups = "drop") %&gt;%
    # Apportion "??" to other countries (see figures/users/users-country.r).
    group_by(date, transport) %&gt;% mutate(across(c(low, high, users), &amp;nbsp; .x * sum(.x) / sum(ifelse(country == "??", 0, .x)))) %&gt;% ungroup() %&gt;% filter(country != "??")</kbd>
&gt; <kbd>userstats %&gt;% filter("2022-09-19" &lt;= date &amp; date &lt;= "2022-09-25") %&gt;%
    group_by(date, transport) %&gt;% mutate(percent = users / sum(users) * 100) %&gt;% filter(country == "ir") %&gt;% ungroup()</kbd>
# A tibble: 7 x 7
  date       transport country    low   high  users percent
  &lt;date&gt;     &lt;chr&gt;     &lt;chr&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;
1 2022-09-19 snowflake ir        205.   207.   206.    1.20
2 2022-09-20 snowflake ir        228.   229.   228.    1.32
3 2022-09-21 snowflake ir       1024.  1025.  1024.    5.48
4 2022-09-22 snowflake ir      20920. 20909. 20914.   50.3
5 2022-09-23 snowflake ir      48467. 48427. 48447.   62.8
6 2022-09-24 snowflake ir      49130. 49083. 49107.   66.0
7 2022-09-25 snowflake ir      59517. 59470. 59493.   67.4
</samp></pre>
</details>
</aside>

<aside class=note id=n-36>
<ul>
<li><a href="https://github.com/net4people/bbs/issues/125">Shutdowns, intensified blocking in Iran since <time>2022-09-21</time></a></li>
<li><a href="https://lists.torproject.org/pipermail/anti-censorship-team/2022-September/000247.html">Need to increase number of tor instances on snowflake-01 bridge, increased usage since yesterday [<time>2022-09-21</time>]</a></li>
<li><a href="https://forum.torproject.net/t/graphs-of-user-counts-from-iran-since-the-onset-of-shutdowns/4843">Graphs of user counts from Iran since the onset of shutdowns</a></li>
</ul>
</aside>

<aside class=footnote id=fn-18>
<sup>18</sup>
<a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40207">Sudden reduction in snowflake-01 bridge bandwidth, 2022-10-04 17:15</a>
</aside>

<aside class=footnote id=fn-19>
<sup>19</sup>
<a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40260">Weird KCP packets received by the client</a>
</aside>

<aside class=footnote id=fn-20>
<sup>20</sup>
<a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40262">Deploy snowflake-server for QueuePacketConn buffer reuse fix (#40260)</a>
</aside>

<aside class=note id=n-77>
<time>2024-05-13</time>:
Cecylia has also demonstrated the effect of the bug in
<a href="https://forum.torproject.org/t/experimenting-with-tor-pluggable-transports-in-shadow/9117/2#snowflake-experimental-results-3">network simulation experiments</a>.
</aside>

<p id=p69>
For most of this history,
the Snowflake bridge was a single server,
which we upgraded and optimized as needed.
As&nbsp;the bridge reached its hardware capacity,
and performance improvements got harder to achieve,
we&nbsp;deployed a second bridge to share the load.
The challenges and design considerations of doing so are discussed in <a href=#multi-bridge>Section&nbsp;4.4</a>.
The new bridge was made available in
Tor Browser&nbsp;12.0 on <time>2022-12-07</time>
and Orbot&nbsp;17 on <time>2024-02-09</time>.
In&nbsp;early 2024, the second bridge handled about
15% of users and
25% of bandwidth.<a class=mark href=#calc-10>&bull;</a>
</p>

<aside class=calc id=calc-10>
<details>
<summary>Calculation</summary>
<pre><samp>&gt; <kbd>library("tidyverse")</kbd>
&gt; <kbd>WANTED_FINGERPRINTS &lt;- c(
    "7659DA0F96B156C322FBFF3ACCC9B9DC01C27C73" = "snowman",
    "5481936581E23D2D178105D44DB6915AB06BFB7F" = "snowflake-01",
    "91DA221A149007D0FD9E5515F5786C3DD07E4BB0" = "snowflake-02"
  )</kbd>
&gt; <kbd>userstats &lt;- read_csv("figures/users/userstats-bridge-transport-multi.csv") %&gt;%
    filter(fingerprint %in% names(WANTED_FINGERPRINTS)) %&gt;%
    mutate(users = users / (coverage / pmax(num_instances, coverage)))</kbd>
&gt; <kbd>bandwidth &lt;- read_csv("figures/users/bandwidth-multi.csv") %&gt;%
    filter(fingerprint %in% names(WANTED_FINGERPRINTS)) %&gt;%
    filter(coverage &gt; 0) %&gt;%
    mutate(bytes = bytes / (coverage / pmax(num_instances, coverage))) %&gt;%
    pivot_wider(id_cols = c(date, fingerprint), names_from = c(type), values_from = c(bytes)) %&gt;%
    mutate(
      good_read = read - `dirreq-read`,
      good_write = write - `dirreq-write`,
      good_avg = (good_read + good_write) / 2,
    )</kbd>
&gt; <kbd>left_join(userstats, bandwidth, by = c("date", "fingerprint")) %&gt;%
    # Subtract out the pro-rated fraction of non-snowflake transports (basically negligible).
    group_by(date, fingerprint) %&gt;%
    mutate(across(c(read, write, `dirreq-read`, `dirreq-write`, good_read, good_write, good_avg), &amp;nbsp; .x * users / sum(users))) %&gt;%
    ungroup() %&gt;%
    filter(transport == "snowflake") %&gt;%
    filter(date &gt;= "2022-12-01") %&gt;%
    mutate(
      year = lubridate::year(date),
      month = lubridate::month(date),
      instance = WANTED_FINGERPRINTS[fingerprint], fingerprint = NULL,
    ) %&gt;%
    group_by(year, month, transport, instance) %&gt;% summarize(users = sum(users), good_avg = sum(good_avg)) %&gt;%
    group_by(year, month, transport) %&gt;%
    mutate(
      users_percent = 100 * users / sum(users, na.rm = TRUE),
      bw_percent = 100 * good_avg / sum(good_avg, na.rm = TRUE),
    ) %&gt;% ungroup() %&gt;% print(n = 40)</kbd>
# A tibble: 32 × 8
    year month transport instance        users good_avg users_percent bw_percent
   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;     &lt;chr&gt;           &lt;dbl&gt;    &lt;dbl&gt;         &lt;dbl&gt;      &lt;dbl&gt;
 1  2022    12 snowflake snowflake-01 2043946.  4.40e14         98.0       96.3
 2  2022    12 snowflake snowflake-02   42158.  1.67e13          2.02       3.66
 3  2023     1 snowflake snowflake-01 2766748.  6.02e14         97.3       95.7
 4  2023     1 snowflake snowflake-02   76198.  2.71e13          2.68       4.30
 5  2023     2 snowflake snowflake-01 2286603.  4.72e14         96.3       93.8
 6  2023     2 snowflake snowflake-02   88801.  3.10e13          3.74       6.16
 7  2023     3 snowflake snowflake-01 1958580.  5.95e14         93.7       91.8
 8  2023     3 snowflake snowflake-02  132598.  5.30e13          6.34       8.18
 9  2023     4 snowflake snowflake-01 2044709.  7.97e14         89.4       86.2
10  2023     4 snowflake snowflake-02  242634.  1.27e14         10.6       13.8
11  2023     5 snowflake snowflake-01 2115663.  8.60e14         84.4       76.7
12  2023     5 snowflake snowflake-02  391264.  2.62e14         15.6       23.3
13  2023     6 snowflake snowflake-01 1889398.  8.21e14         81.6       76.8
14  2023     6 snowflake snowflake-02  425019.  2.48e14         18.4       23.2
15  2023     7 snowflake snowflake-01 1840693.  7.98e14         81.2       79.6
16  2023     7 snowflake snowflake-02  426490.  2.04e14         18.8       20.4
17  2023     8 snowflake snowflake-01 1718368.  7.55e14         83.9       84.0
18  2023     8 snowflake snowflake-02  328826.  1.44e14         16.1       16.0
19  2023     9 snowflake snowflake-01 1260765.  8.25e14         86.4       92.3
20  2023     9 snowflake snowflake-02  198159.  6.92e13         13.6        7.73
21  2023    10 snowflake snowflake-01  965871.  7.07e14         90.5       78.5
22  2023    10 snowflake snowflake-02  101105.  1.94e14          9.48      21.5
23  2023    11 snowflake snowflake-01  925517.  6.84e14         86.4       72.7
24  2023    11 snowflake snowflake-02  146157.  2.56e14         13.6       27.3
25  2023    12 snowflake snowflake-01 1000067.  7.51e14         85.2       73.7
26  2023    12 snowflake snowflake-02  173915.  2.68e14         14.8       26.3
27  2024     1 snowflake snowflake-01 1055248.  8.20e14         84.2       75.0
28  2024     1 snowflake snowflake-02  197708.  2.74e14         15.8       25.0
29  2024     2 snowflake snowflake-01 1131929.  8.14e14         83.4       72.7
30  2024     2 snowflake snowflake-02  226019.  3.06e14         16.6       27.3
31  2024     3 snowflake snowflake-01  101981.  7.31e13         91.0       77.0
32  2024     3 snowflake snowflake-02   10081.  2.19e13          9.00      23.0
</samp></pre>
</details>
</aside>

<p id=p70>
The drop in users on <time>2023-09-20</time>
was not caused by any censor action;
rather, it&nbsp;was an unexpected change in the cloud
infrastructure we used for domain fronting rendezvous.
The front domain we had been using
changed its hosting to a different CDN,
which caused client rendezvous messages to fail to reach the broker.<a class=mark href=#fn-21><sup>21</sup></a>
We&nbsp;made releases
with alternative front domains<a class=mark href=#fn-22><sup>22</sup></a>,
but it took time for users to adjust.
Something similar happened on <time>2024-03-01</time>,
when the CDN we had been using in the default configuration
of domain fronting rendezvous
stopped supporting domain fronting.<a class=mark href=#fn-23><sup>23</sup></a>
It&nbsp;happened just before the deadline for this paper,
so&nbsp;we cannot yet comment on any long-term effects,
but <a href=#fig-client-counts>Figure&nbsp;5</a> shows an immediate decline in users and bandwidth
of about&nbsp;30%.
</p>

<aside class=footnote id=fn-21>
<sup>21</sup>
<ul>
<li><a href="https://forum.torproject.org/t/9346">Problems with Snowflake since 2023-09-20: “broker failure Unexpected error, no answer.”</a></li>
<li><a href="https://lists.torproject.org/pipermail/anti-censorship-team/2023-September/000317.html">Trying to understand multi-bridge dynamics post after Fastly/Cloudflare domain front change</a></li>
</ul>
</aside>

<aside class=footnote id=fn-22>
<sup>22</sup>
<ul>
<li><a href="https://bugs.torproject.org/tpo/applications/tor-browser/42120">Use foursquare as domain front for snowflake</a></li>
<li><a href="https://gitlab.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/-/merge_requests/182">Randomly select front domain from comma-separated list</a></li>
<li><a href="https://blog.torproject.org/new-alpha-release-tor-browser-130a5/">New Alpha Release: Tor Browser 13.0a5 (Android, Windows, macOS, Linux)</a></li>
<li><a href="https://blog.torproject.org/new-release-tor-browser-1255/">New Release: Tor Browser 12.5.5</a></li>
</ul>
</aside>

<aside class=footnote id=fn-23>
<sup>23</sup>
<a href="https://bugs.torproject.org/tpo/anti-censorship/team/135">Fastly blocked domain fronting</a>
</aside>

<p id=p71>
As&nbsp;of <time>2024-03-01</time>,
Snowflake had transferred a lifetime total of 15&nbsp;PB of circumvention data.<a class=mark href=#calc-11>&bull;</a>
Here we mean goodput: Tor TLS traffic inside the tunnel,
ignoring WebRTC, WebSocket, and KCP/<wbr>smux overhead.
At&nbsp;that time, around 1.2% of Tor users<a class=mark href=#n-37>&bull;</a>
(25%&nbsp;of bridge users) were using Snowflake.<a class=mark href=#calc-12>&bull;</a>
</p>

<aside class=calc id=calc-11>
<details>
<summary>Calculation</summary>
<pre><samp>&gt; <kbd>library("tidyverse")</kbd>
&gt; <kbd>WANTED_FINGERPRINTS &lt;- c(
    "7659DA0F96B156C322FBFF3ACCC9B9DC01C27C73" = "snowman",
    "5481936581E23D2D178105D44DB6915AB06BFB7F" = "snowflake-01",
    "91DA221A149007D0FD9E5515F5786C3DD07E4BB0" = "snowflake-02"
  )</kbd>
&gt; <kbd>options(width = 200)</kbd>
&gt; <kbd>userstats &lt;- read_csv("figures/users/userstats-bridge-transport-multi.csv") %&gt;%
    filter(fingerprint %in% names(WANTED_FINGERPRINTS)) %&gt;%
    mutate(users = users / (coverage / pmax(num_instances, coverage)))</kbd>
&gt; <kbd>bandwidth &lt;- read_csv("figures/users/bandwidth-multi.csv") %&gt;%
    filter(fingerprint %in% names(WANTED_FINGERPRINTS)) %&gt;%
    filter(coverage &gt; 0) %&gt;%
    mutate(bytes = bytes / (coverage / pmax(num_instances, coverage))) %&gt;%
    pivot_wider(id_cols = c(date, fingerprint), names_from = c(type), values_from = c(bytes)) %&gt;%
    mutate(
      good_read = read - `dirreq-read`,
      good_write = write - `dirreq-write`,
      good_avg = (good_read + good_write) / 2
    )</kbd>
&gt; <kbd>left_join(userstats, bandwidth, by = c("date", "fingerprint")) %&gt;%
    # Subtract out the pro-rated fraction of non-snowflake transports (basically negligible).
    group_by(date, fingerprint) %&gt;%
    mutate(across(c(read, write, `dirreq-read`, `dirreq-write`, good_read, good_write, good_avg), &amp;nbsp; .x * users / sum(users))) %&gt;%
    ungroup() %&gt;%
    filter(transport == "snowflake") %&gt;%
    filter(date &lt; "2024-03-01") %&gt;%
    summarize(
      date = last(date),
      across(c(read, write, `dirreq-read`, `dirreq-write`, good_read, good_write, good_avg), sum, na.rm = TRUE)
    ) %&gt;%
    mutate(across(c(read, write, `dirreq-read`, `dirreq-write`, good_read, good_write, good_avg), scales::label_bytes(units = "auto_si", accuracy = 0.01)))</kbd>
# A tibble: 1 × 8
  date       read     write    `dirreq-read` `dirreq-write` good_read good_write good_avg
  &lt;date&gt;     &lt;chr&gt;    &lt;chr&gt;    &lt;chr&gt;         &lt;chr&gt;          &lt;chr&gt;     &lt;chr&gt;      &lt;chr&gt;
1 2024-02-29 15.12 PB 15.16 PB 10.12 TB      188.88 TB      15.11 PB  14.97 PB   15.04 PB
</samp></pre>
</details>
</aside>

<aside class=note id=n-37>
It was a higher fraction before
<a href="https://bugs.torproject.org/tpo/network-health/analysis/59">the addition of about 2 M users from Germany</a>
in <time datetime=2023-06>June 2023</time>:
</aside>

<aside class=calc id=calc-12>
<details>
<summary>Calculation</summary>
<pre><samp>&gt; <kbd>library("tidyverse")</kbd>
&gt; <kbd>WANTED_FINGERPRINTS &lt;- c(
    "7659DA0F96B156C322FBFF3ACCC9B9DC01C27C73" = "snowman",
    "5481936581E23D2D178105D44DB6915AB06BFB7F" = "snowflake-01",
    "91DA221A149007D0FD9E5515F5786C3DD07E4BB0" = "snowflake-02"
  )</kbd>
&gt; <kbd>DATE_RANGE &lt;- as.Date(c("2024-02-23", "2024-03-01"))</kbd>
&gt; <kbd>userstats &lt;- bind_rows(
    read_csv("figures/users/userstats-relay-country.csv", comment = "#") %&gt;%
      mutate(mode = "relay"),
    read_csv("figures/users/userstats-bridge-transport.csv", comment = "#") %&gt;%
      filter(transport != "snowflake") %&gt;%
      mutate(mode = "bridge"),
    # Use our own numbers for Snowflake users, rather than Tor Metrics'.
    read_csv("figures/users/userstats-bridge-transport-multi.csv") %&gt;%
      filter(fingerprint %in% names(WANTED_FINGERPRINTS)) %&gt;%
      filter(transport == "snowflake") %&gt;%
      mutate(users = users / (coverage / pmax(num_instances, coverage))) %&gt;%
      group_by(date, transport) %&gt;% summarize(users = sum(users, na.rm = TRUE), .groups = "drop") %&gt;%
      mutate(frac = 100, mode = "bridge")
  ) %&gt;%
  filter(lubridate::`%within%`(date, do.call(lubridate::interval, as.list(DATE_RANGE)))) %&gt;%
    mutate(transport = if_else(mode == "bridge" &amp; transport != "snowflake", "non-snowflake", transport)) %&gt;%
    group_by(mode, transport) %&gt;% summarize(users = sum(users, na.rm = TRUE), .groups = "drop")</kbd>
&gt; <kbd>userstats %&gt;% mutate(percent = 100 * users / sum(users))</kbd>
# A tibble: 3 × 4
  mode   transport         users percent
  &lt;chr&gt;  &lt;chr&gt;             &lt;dbl&gt;   &lt;dbl&gt;
1 bridge non-snowflake  1137811     3.50
2 bridge snowflake       389453.    1.20
3 relay  NA            30939204    95.3
&gt; <kbd>userstats %&gt;% filter(mode == "bridge") %&gt;% mutate(percent = 100 * users / sum(users))</kbd>
# A tibble: 2 × 4
  mode   transport        users percent
  &lt;chr&gt;  &lt;chr&gt;            &lt;dbl&gt;   &lt;dbl&gt;
1 bridge non-snowflake 1137811     74.5
2 bridge snowflake      389453.    25.5
</samp></pre>
</details>
</aside>

</section>

<section id=proxies data-number=4.2>
<h3><a href=#proxies><span class=number>4.2</span> Number and type of proxies</a></h3>

<p id=p72>
Snowflake’s effectiveness depends on its pool of proxies,
of which there are several types.
The primary type is the web browser extension<a class=mark href=#n-38>&bull;</a>,
which runs in the background in volunteers’ browsers
and quietly serves clients.
There is a “web badge” version of the proxy that does not require installation.
It&nbsp;uses the same JavaScript code as the extension, but runs in an ordinary web page.
Some people leave a browser tab idling on the web badge,
rather than installing a browser extension.
There is also a command-line implementation of the proxy
that does not require a browser.<a class=mark href=#n-39>&bull;</a>,
This version is convenient to install on a rented VPS, for example.
Long-term proxies running at fixed IP addresses
are somewhat at odds with Snowflake’s goal of proxy address diversity,
but these standalone, command-line proxies are valuable because
they tend to have less restrictive NATs,
which makes them compatible with more clients.
Finally, Orbot,
as&nbsp;well as being able to <em>use</em> Snowflake for circumvention,
can also <em>provide</em> Snowflake proxy service to others,
a&nbsp;feature called “kindness mode.”
<!--
Only so called in Orbot v17+, which should be current by the time the paper is submitted.
As of 2024-02-09, according to Nathan in #guardianproject:matrix.org:
Q: do you have a sense for what percentage of users are on the v16 track vs. v17?
&gt; A: 70% on v16, 30% on v17 out of 1.5 to 2M total active users
2023-02-09 "This is the version we are pushing out to EVERYONE." https://github.com/guardianproject/orbot/releases/tag/17.2.1-RC-1-tor-0.4.8.7
2024-03-05 "Updated on Feb 20, 2024" https://play.google.com/store/apps/details?id=org.torproject.torbrowser
-->
</p>

<aside class=note id=n-38>
<a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/23888">Creating a Snowflake WebExtension addon</a>
</aside>

<aside class=note id=n-39>
<a href="https://github.com/keroserene/snowflake/pull/41">Golang implementation of standalone snowflake proxy</a>
</aside>

<p id=p73>
We worked with the Tor Project’s network health team to collect privacy-preserving metrics
of client and proxy rendezvous interactions at the broker,
and publish them in the same way as the bridge metrics of <a href=#clients>Section&nbsp;4.1</a>.<a class=mark href=#fn-24><sup>24</sup></a>
The metrics represent counts of proxy types,
unique proxy IP addresses and geolocated country codes,
NAT types (<a href=#connection>Section&nbsp;2.2</a>), and
success rates of matching clients with proxies.
Aggregate metrics
are published at 24-hour intervals.<a class=mark href=#fn-25><sup>25</sup></a>
The broker does not record nor publish the IP addresses
of clients or proxies.
Metrics concerning client polls are rounded to multiples of&nbsp;8,
in&nbsp;accordance with established Tor Metrics practice.<a class=mark href=#n-40>&bull;</a>,
</p>

<aside class=footnote id=fn-24>
<sup>24</sup>
<a href="https://bugs.torproject.org/tpo/network-health/metrics/collector/29461">Add a Snowflake module</a>
</aside>

<aside class=footnote id=fn-25>
<sup>25</sup>
<a href="https://metrics.torproject.org/collector.html#snowflake-stats">https://metrics.torproject.org/collector.html#snowflake-stats</a>
</aside>

<aside class=note id=n-40>
<a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/21315#note_2591581">“With relays and bridges, we round the counts up to the nearest multiple of 8.”</a>
</aside>


<figure id=fig-proxy-type data-number=6>
<picture>
<source srcset=proxy-type.svg type="image/svg+xml" width=1000 height=375>
<img src=proxy-type.png width=1000 height=375 alt="
Line graph showing the relative proportion of
“Browser extension”, “Orbot”, “Command-line”, and “Web badge”
proxy types from July 2021 to March 2024.
The latest quantities are about
107,000 for Browser extension,
21,000 for Orbot,
4,600 for Command-line, and
600 for Web badge.
">
</picture>
<figcaption>
<a href=#fig-proxy-type>Figure&nbsp;6</a>:
Unique proxy IP addresses per day,
by proxy type.
The two steps in the graph correspond
to the invasion of Ukraine by Russia in <time datetime=2022-02>February&nbsp;2022</time><a class=mark href=#n-41>&bull;</a>,
and network restrictions in Iran beginning <time datetime=2022-09>September&nbsp;2022</time><a class=mark href=#n-42>&bull;</a>,
at which times there were campaigns
to encourage running Snowflake proxies.
Unknown proxy types (fewer than&nbsp;50 instances) are not shown.
</figcaption>
<!--
2021-02-23 https://github.com/guardianproject/orbot/releases/tag/16.4.1-BETA-2-tor.0.4.4.6
"experimental mode to enable running as a Snowflake proxy"
2021-07-14 https://github.com/tladesignz/IPtProxy/commit/228e9e61e285ee548a42d6bee487577e44630695
IPtProxy 1.1.0 changes its proxy type from "standalone" to "iptproxy"
2021-12-20 https://github.com/guardianproject/orbot/releases/tag/16.5.2-RC-1-tor.0.4.6.8
Orbot updates IPtProxy from 1.0.0 to 1.2.0 https://github.com/guardianproject/orbot/commit/57add48cd904afe94363219887cd142bb5cf6696
2022-01-03 https://github.com/guardianproject/orbot/releases/tag/16.5.2-RC-5-tor.0.4.6.9
This is close to the date (2022-01-05) when there's sudden growth in "Unknown",
which is probably Orbot self-reporting as "iptproxy" and the broker throwing away that label for being unrecognized.
2022-03-21 https://gitlab.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/-/merge_requests/82
Broker starts to recognize "iptproxy" as a probe type, but not deployed yet.
2022-05-03 https://github.com/tladesignz/IPtProxy/commit/c6ba25ef6ce8449476f734c626eadffdf55d0519
IPtProxy 1.6.0 adds 'ProxyType: "iptproxy"' (no effective change, had already been done in a patch).
2022-06-21 https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40151
Broker deployment, broker starts recording "iptproxy" in descriptors.
2022-07-05 https://github.com/guardianproject/orbot/releases/tag/16.6.2-RC-1-tor.0.4.7.8
Orbot 16.6.2 RC 1 upgrades to IPtProxy 1.6.0.
2022-08-02 https://github.com/guardianproject/orbot/releases/tag/17.0.0-ALPHA-1-tor.0.4.7.8
"updated UI based on new design spec: https://github.com/guardianproject/orbot/blob/NEW_UX/docs/design-spec-kindness-mode.md"
"improved support for Snowflake Proxying "kindness" / volunteer mode"
2023-01-13 https://github.com/guardianproject/orbot/releases/tag/17.0.0-BETA-1-tor.0.4.7.11
"easy access to Snowflake proxy 'kindness' mode"
-->
</figure>

<aside class=note id=n-41>
<ul>
<li><a href="https://twitter.com/torproject/status/1497276960556429324"><time>2022-02-25</time></a>: “Russian users, you can defeat Tor censorship by getting a Tor bridge from our official Telegram bot: <a href="https://t.me.GetBridgesBot">t.me/GetBridgesBot</a>. Or use Snowflake. ❄️”</li>
<li><a href="https://twitter.com/0xggus/status/1497224413829283877"><time>2022-02-25</time></a>: “URGENT!🟡 If you want to help the antiwar activists in Russia and human rights defenders around the world, you can run a snowflake proxy❄️ and/or a Tor bridge. 
Help us circumvent the Tor block in Russia! #Ukraine #RussiaUkraineWar”</li>
</ul>
</aside>

<aside class=note id=n-42>
<ul>
<li><a href="https://twitter.com/torproject/status/1573670895696183303">2022-09-24</a>: “Snowflake is helping people in Iran and other countries circumvent Internet censorship.<br>
Let people know you’re operating a Snowflake proxy by downloading and printing our Snowflake sticker pack!”</li>
<li><a href="https://www.eff.org/deeplinks/2022/10/snowflake-makes-it-easy-anyone-fight-censorship">2022-10-03: Snowflake Makes It Easy For Anyone to Fight Censorship</a></li>
</ul>
</aside>

<p id=p74>
<a href=#fig-proxy-type>Figure&nbsp;6</a> shows the number of proxies by type.
Web browser extension proxies predominate,
representing about 80%
of 140,000 daily IP addresses.<a class=mark href=#calc-13>&bull;</a>
For comparison, there were about 1,900
of the more traditional style of Tor bridge at this time.<a class=mark href=#n-43>&bull;</a>
The difference in number is attributable to the relative ease
of running a Snowflake proxy versus a Tor bridge—though
the comparison is not quite direct,
because Tor bridges have better defenses
against enumeration than do Snowflake proxies.
</p>

<aside class=calc id=calc-13>
<details>
<summary>Calculation</summary>
<pre><samp>&gt; <kbd>library("tidyverse")</kbd>
&gt; <kbd>proxy_type &lt;- read_csv("figures/proxies/proxy-type.csv", col_types = cols()) %&gt;% filter("2024-02-01" &lt;= date &amp; date &lt; "2024-03-01")</kbd>
&gt; <kbd>proxy_type %&gt;% group_by(type) %&gt;% summarize(unique_ips = sum(unique_ips / coverage)) %&gt;% mutate(percent = 100 * unique_ips / sum(unique_ips)) %&gt;% ungroup()</kbd>
# A tibble: 5 × 3
  type       unique_ips    percent
  &lt;chr&gt;           &lt;dbl&gt;      &lt;dbl&gt;
1 badge          19517.  0.473
2 iptproxy      652048. 15.8
3 standalone    126034.  3.05
4 webext       3332056. 80.7
5 NA                 1   0.0000242
&gt; <kbd>proxy_type %&gt;% group_by(date) %&gt;% summarize(unique_ips = sum(unique_ips / coverage)) %&gt;% tail()</kbd>
# A tibble: 6 × 2
  date       unique_ips
  &lt;date&gt;          &lt;dbl&gt;
1 2024-02-24    131969.
2 2024-02-25    133617.
3 2024-02-26    146474.
4 2024-02-27    147986.
5 2024-02-28    147488.
6 2024-02-29    146640.
</samp></pre>
</details>
</aside>

<aside class=note id=n-43>
<a href="https://metrics.torproject.org/networksize.csv?start=2024-02-01&end=2024-02-29">https://metrics.torproject.org/networksize.csv?start=2024-02-01&end=2024-02-29</a>
<pre>
date,relays,bridges
2024-02-27,7478,1952
2024-02-28,7506,1946
2024-02-29,7518,1940
</pre>
</aside>

<p id=p75>
It&nbsp;was not clear, at the outset,
that it would even be possible to attract
enough proxies to support a reasonable number of users
with meaningful blocking resistance.<a class=mark href=#n-44>&bull;</a>
Lowering the technical barriers to running a proxy was only part of&nbsp;it;
it&nbsp;also took intentional advocacy and outreach.
In&nbsp;the early days, circa&nbsp;2017,
the only consistent proxy support was
a few command-line proxies,
run by us for the benefit of alpha testers.<a class=mark href=#n-45>&bull;</a>
The browser extension became available in mid-2019.<a class=mark href=#fn-26><sup>26</sup></a><a class=mark href=#fn-27><sup>27</sup></a>
Later in 2019,
additional proxy capacity came when Cupcake,
a&nbsp;browser extension for flash proxy with an existing user base,
was repurposed for Snowflake.<a class=mark href=#fn-28><sup>28</sup></a><a class=mark href=#n-46>&bull;</a>
Orbot’s proxy feature was added in version 16.4.1 in <time datetime=2021-02>February&nbsp;2021</time>.<a class=mark href=#fn-29><sup>29</sup></a>
(In&nbsp;<a href=#fig-proxy-type>Figure&nbsp;6</a>, Orbot is counted with command-line proxies
until <time datetime=2022-01>January&nbsp;2022</time>, when it got its own proxy type designation.<a class=mark href=#n-47>&bull;</a>)
</p>

<aside class=note id=n-44>
<a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/20813">Start producing snowflakes</a>
</aside>

<aside class=note id=n-45>
<a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/25688">“The three fallback proxy-go instances…”</a>
</aside>

<aside class=footnote id=fn-26>
<sup>26</sup>
<a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/30931#note_2593598">“I tagged a release as, webext-0.0.1 and published it”</a>
</aside>

<aside class=footnote id=fn-27>
<sup>27</sup>
<a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/30999#note_2593718">“Looks like it got published”</a>
</aside>

<aside class=footnote id=fn-28>
<sup>28</sup>
<ul>
<li><a href="https://github.com/glamrock/cupcake/issues/24">Snowflake integration</a></li>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/31497">Link Cupcake from snowflake.torproject.org</a></li>
</ul>
</aside>

<aside class=note id=n-46>
Cupcake stopped working when we
<a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/29207#note_2592849">changed the proxy–broker protocol</a>.
</aside>

<aside class=footnote id=fn-29>
<sup>29</sup>
<ul>
<li><a href="https://github.com/guardianproject/orbot/releases/tag/16.4.1-BETA-2-tor.0.4.4.6">Orbot 16.4.1-BETA-2-tor.0.4.4.6</a></li>
<li><a href="https://github.com/guardianproject/orbot/releases/tag/16.4.1-RC-1-tor.0.4.4.6">Orbot 16.4.1-RC-1-tor.0.4.4.6</a></li>
<!-- https://github.com/guardianproject/orbot/blob/a69f39bb37469e65730d0751519848ec29001959/CHANGELOG#L714 /** 16.4.1-RC-1 / 9 April 2021 / c80f18ae2508b73fcbfd6e09b394a2a196de7459 **/ -->
<li><a href="https://lists.mayfirst.org/pipermail/guardian-dev/2023-July/005708.html">First version of Orbot able to be a Snowflake proxy</a></li>
<!--
16.4.1-BETA-2-tor.0.4.4.6 was released and promoted first, and had a visible effect on proxy counts,
though 16.4.1-RC-1-tor.0.4.4.6 was the "real" 16.4.1 release.
-->
</ul>
</aside>

<aside class=note id=n-47>
See history in figures/proxies/proxy-type.r in the
<a href=#links>source code</a>.
</aside>

<p id=p76>
It&nbsp;is worth reflecting
on the popularity of the browser extension
as compared to the web badge.
A&nbsp;web badge had been envisioned
as the main source of proxies in flash proxy<a class=mark href=#n-48>&bull;</a>,
the idea being that people’s browsers
would automatically become proxies
while on sites that had the flash proxy badge installed,
unless they checked an option to prevent&nbsp;it.
We&nbsp;decided, early&nbsp;on, that flash proxy’s opt-out permission had been a mistake,
<!--
Date: Tue, 6 Dec 2016 18:38:40 -0800
From: David Fifield <dcf@torproject.org>
To: Arlo Breault <arlo@torproject.org>
Cc: Serene <serene@torproject.org>
Subject: Re: Snowing
Message-ID: <20161207023840.mli4cymr6s3aanpu@happy.bamsoftware.com>

My original plan was to repurpose existing flash proxy badges as
Snowflake badges. But, I am thinking more and more that Snowflake should
use an opt-in model, rather than opt-out. The opt-out model of flash
proxy always bothered me. I think there’s a good chance it would cause
trouble for us if Snowflake becomes popular. So I’d like to see
Snowflake use opt-in badges (and Cupcake) only.
-->
and that Snowflake would be opt-in.
To&nbsp;run a proxy, a person must take a positive action,
such as installing a browser extension
or activating a toggle on a web page.<a class=mark href=#n-49>&bull;</a>
Our initial worry that this policy
would limit the number of proxies turned out to be unfounded.
People find an informative, interactive proxy control panel more appealing
than a nondescript badge graphic,
and install the browser extension in greater numbers
than ever used the web badge in flash proxy.
</p>

<aside class=note id=n-48>
<p id=p77>
By the end of its run, flash proxy had
<a href="https://www.bamsoftware.com/talks/ee380-flashproxy/index.html#s15">also gained</a>
browser extensions including Cupcake:
</p>
<ul>
<li><a href="https://bugs.torproject.org/legacy/trac/7721">Chrome browser add-on</a></li>
<li><a href="https://github.com/reezer/tor-flashproxy-badge/">Tor Flashproxy Badge" [for Firefox]</a></li>
</ul>
<p id=p78>
And a standalone proxy:
</p>
<ul>
<li><a href="https://bugs.torproject.org/legacy/trac/7944">Node.js standalone flash proxy</a></li>
</ul>
</aside>

<aside class=note id=n-49>
<a href="https://github.com/keroserene/snowflake/issues/21">Prepare a Snowflake “options” page, like in flashproxy</a>
</aside>

</section>

<section id=proxy-churn data-number=4.3>
<h3><a href=#proxy-churn><span class=number>4.3</span> Proxy churn</a></h3>

<p id=p79>
The size of the proxy pool is not the only measure of its quality.
Also important is its “churn,” the rate at which
it is replenished with fresh proxy IP addresses.
Churn determines how hard a censor would have to work
to keep a blocklist of proxy IP addresses up to date;
or alternatively,
how quickly a momentarily complete blocklist
would lose effectiveness.
</p>

<p id=p80>
We ran an experiment to measure churn.<a class=mark href=#fn-30><sup>30</sup></a>
Our technique was to record the set of proxy IP addresses
seen by the broker over an interval of time,
then compute the size of the intersection with other sets
in nearby intervals, up&nbsp;to 40 hours later.
Every hour, the broker recorded a snapshot of
proxy IP addresses it had seen in the past hour.
To&nbsp;avoid the risk of storing real proxy IP addresses,
each snapshot was not a transparent list,
but a HyperLogLog++ sketch&nbsp;<a href=#ref:Heule2013a class=cite>[<span class=number>15</span>]</a>,
a&nbsp;probabilistic data structure for estimating
the number of distinct elements in a multiset.
Proxy IP addresses were hashed with a secret string
(discarded at the end of the experiment)
before being added to a sketch,
to&nbsp;prevent their being recovered from our published data.
A&nbsp;sketch supports two basic operations: count and merge.
Given a sketch&nbsp;<var>X</var>,
we&nbsp;may compute an approximate count |<var>X</var>|
of its unique elements,
and given two sketches <var>X</var> and&nbsp;<var>Y</var>,
we&nbsp;may merge them into a new sketch
representing the union <var>X</var>&nbsp;∪&nbsp;<var>Y</var>.
The quantity we are interested in,
namely
the size of the intersection of two sketches,
is&nbsp;computed using the formula
|<var>X</var>| + |<var>Y</var>| − |<var>X</var>&nbsp;∪&nbsp;<var>Y</var>|.
This computation estimates
how many proxy IP addresses are shared between
two samples.
</p>

<aside class=footnote id=fn-30>
<sup>30</sup>
<a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/34075">Implement metrics to measure snowflake churn</a>
</aside>

<figure id=fig-proxy-count-decay data-number=7>
<picture>
<source srcset=proxy-count-decay.svg type="image/svg+xml" width=1000 height=420>
<img src=proxy-count-decay.png width=1000 height=420 alt="
A primary line graph shown in black is labeled
“Unique proxy IP addresses per 24-hour window”.
It slightly oscillates on daily and weekly cycles,
averaging around 120,000.
Descending from the black line every 24 hours are blue lines
labeled “Shared IP addresses 1, 2, …, 40 hours later”.
These generally descend to about 50,000 after 24 hours and fade out after 40 hours.
The horizontal time axis goes from Jan 01 to Jan 31 2023.
">
</picture>
<figcaption>
<a href=#fig-proxy-count-decay>Figure&nbsp;7</a>:
Proxy churn in <time datetime=2023-01>January 2023</time>.
The dark upper line shows the number
of unique proxy IP addresses in overlapping 24-hour windows.
The lighter, descending lines indicate
how many of the same IP addresses were in later 24-hour windows,
at&nbsp;1-hour increments up to 40 hours later.
It&nbsp;takes about 20&nbsp;hours for 50% of the proxy pool to turn over.
</figcaption>
</figure>

<p id=p81>
The broker recorded churn logs between
<time>2022-07-22</time> and
<time>2023-10-16</time>.
<a href=#fig-proxy-count-decay>Figure&nbsp;7</a>
shows results from <time datetime=2023-01>January 2023</time>,
which are representative.
Proxy activity has a daily cycle,
so&nbsp;we merged consecutive sketches into 24-hour windows.
Starting from a reference window,
we&nbsp;computed the size of its intersection with other 24-hour windows,
offset by +1,&nbsp;+2,&nbsp;…,&nbsp;+40 hours relative to the reference.
After 1&nbsp;hour, the shifted window had, on average,
97.3% of addresses in common with the reference;
after 12&nbsp;hours, the fraction had fallen to 68.8%;
after 24&nbsp;hours, 38.2%;
and after 40&nbsp;hours, 27.6%.<a class=mark href=#calc-14>&bull;</a>
</p>

<aside class=calc id=calc-14>
<details>
<summary>Calculation</summary>
<pre><samp>&gt; <kbd>library("tidyverse")</kbd>
&gt; <kbd>options(width = 200)</kbd>
&gt; <kbd>DATE_RANGE &lt;- as.Date(c("2023-01-01", "2023-02-01"))</kbd>
&gt; <kbd>read_csv("figures/proxy-churn/proxy-churn-windows.csv") %&gt;%
    filter(lubridate::`%within%`(reference_timestamp_end, do.call(lubridate::interval, as.list(DATE_RANGE)))) %&gt;%
    mutate(
      sample_offset_hours = round(sample_timestamp_end_offset / 3600),
      intersection_count = reference_count + sample_count - union_count
    ) %&gt;%
    group_by(sample_offset_hours) %&gt;%
    summarize(
      across(c(reference_count, sample_count, union_count, intersection_count), mean),
      intersection_percent = 100 * intersection_count / reference_count,
      .groups = "drop"
    ) %&gt;%
    filter(sample_offset_hours %in% c(0, 1, 2, 3, 4, 8, 12, 18, 24, 36, 40))</kbd>
# A tibble: 11 x 6
   sample_offset_hours reference_count sample_count union_count intersection_count intersection_percent
                 &lt;dbl&gt;           &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;              &lt;dbl&gt;                &lt;dbl&gt;
 1                   0         119654.      119654.     119654.            119654.                100
 2                   1         119654.      119704.     122907.            116450.                 97.3
 3                   2         119654.      119754.     126142.            113266.                 94.7
 4                   3         119654.      119804.     129359.            110099.                 92.0
 5                   4         119654.      119854.     132529.            106980.                 89.4
 6                   8         119654.      120060.     145141.             94572.                 79.0
 7                  12         119654.      120292.     157684.             82262.                 68.8
 8                  18         119654.      120649.     176400.             63903.                 53.4
 9                  24         119654.      120970.     194892.             45732.                 38.2
10                  36         119654.      121500.     206542.             34612.                 28.9
11                  40         119654.      121639.     208269.             33024.                 27.6
</samp></pre>
</details>
</aside>

</section>

<section id=multi-bridge data-number=4.4>
<h3><a href=#multi-bridge><span class=number>4.4</span> Multiple bridges</a></h3>

<!--
"Distributed Snowflake Server Support" https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40129
-->

<p id=p82>
In the conceptual model of <a href=#fig-architecture>Figure&nbsp;1</a>, the bridge
is a single, centralized entity.
It&nbsp;<em>can</em> be centralized
because it is never accessed directly,
but only via temporary proxies.
Unlike more traditional static proxy systems,
Snowflake does not benefit, in&nbsp;terms of blocking resistance,
from having multiple bridges.
For reasons of scaling and performance, though,
it&nbsp;can be useful for “the” bridge to be realized as
multiple servers.
Even with hardware upgrades and software optimizations,
our single bridge began to hit performance limits
in late 2022 (particularly after the events in Iran of <a href=#clients>Section&nbsp;4.1</a>),
and we had to find ways of distributing bridge capacity
to permit continued scaling.
Our deployment now uses two bridges.
</p>

<p id=p83>
A&nbsp;multi-bridge system
might be designed in many ways.
In&nbsp;ours,
the client tells the broker
what bridge it wants to use
in its rendezvous message.
The broker conveys the choice to the proxy,
and the proxy connects to the client’s chosen bridge.<a class=mark href=#fn-31><sup>31</sup></a>
This may be compared to alternative designs
in which the decision of what bridge to use
is made by the broker or the proxy.
Our design was largely dictated by technical constraints
related to interfacing with Tor.
Different designs may make sense with other deployments.
</p>

<aside class=footnote id=fn-31>
<sup>31</sup>
<a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/28651#note_2786323">Prepare all pieces of the snowflake pipeline for a second snowflake bridge</a>
</aside>

<p id=p84>
One minor consideration is the Turbo Tunnel layer.
Recall from <a href=#data-transfer>Section&nbsp;2.3</a> that Snowflake
maintains a virtual end-to-end session
between the client and the bridge,
independent of the temporary proxies.
This is made possible by state stored at the bridge:
a&nbsp;table of clients, reassembly buffers,
transmission queues, timers, and so&nbsp;on.<a class=mark href=#n-50>&bull;</a>
The state variables are not synchronized between bridges,
which means a client session begun on one bridge
must remain with that bridge,
because no other
has the context to make the packets
of the session meaningful.
When it is the client that chooses the bridge,
this is easy to deal with:
the client keeps its choice consistent
in all rendezvous messages throughout a session.
If&nbsp;the choice were instead made by the broker or proxy,
it&nbsp;might be dealt with by hashing
the client’s session identifier string to an index,
as&nbsp;long as the set of bridges does not change too frequently.
</p>

<aside class=note id=n-50>
<ul>
<li><a href="https://github.com/xtaci/kcp-go/blob/03b584b84eddd95cc03dbff65fc9cc5cbdf80c6b/kcp.go#L132"><code>type KCP</code></a></li>
<li><a href="https://github.com/xtaci/kcp-go/blob/03b584b84eddd95cc03dbff65fc9cc5cbdf80c6b/sess.go#L61"><code>type UDPSession</code></a></li>
</ul>
</aside>

<p id=p85>
Another difficulty, harder to work around,
has to do with Tor bridge authentication.
A&nbsp;Tor bridge is identified
by a long-term identity public key.
If,&nbsp;on connecting to a bridge,
the client finds that the bridge’s identity is not the expected one,
the client terminates the connection&nbsp;<a href=#ref:tor-spec-negotiating-channels class=cite>[<span class=number>5</span>]</a><a class=mark href=#n-51>&bull;</a>.
<!--
% connection_or_client_learned_peer_id https://gitlab.torproject.org/tpo/core/tor/-/blob/tor-0.4.7.13/src/core/or/connection_or.c#L1897
% [warn] Tried connecting to router at 192.0.2.3:80 ID=<none> RSA_ID=2B280B23E1107BB62ABFC40DDCC8824814F80A71, but RSA + ed25519 identity keys were not as expected: wanted 1111111111111111111111111111111111111111 + no ed25519 key but got 2B280B23E1107BB62ABFC40DDCC8824814F80A72 + 1zOHpg+FxqQfi/6jDLtCpHHqBTH8gjYmCKXkus1D5Ko.
% [warn] Problem bootstrapping. Stuck at 14% (handshake): Handshaking with a relay. (Unexpected identity in router certificate; IDENTITY; count 1; recommendation warn; host 1111111111111111111111111111111111111111 at 192.0.2.3:80)
-->
The Tor client can configure at most one identity per bridge;
there is nothing like a certificate, for example,
to indicate that multiple identities should be considered equivalent.
This constraint leaves two options:
either all Snowflake bridges must share the same cryptographic identity;
or&nbsp;else it must be the client that chooses the bridge
(and therefore knows what bridge identity to expect).
While it would be possible to synchronize Tor identity keys across bridges,
we&nbsp;preferred to keep keys independent,
so&nbsp;that the effect of a security compromise
at a bridge would be limited to that bridge only.
</p>

<aside class=note id=n-51>
<a href="https://lists.torproject.org/pipermail/tor-dev/2024-February/014886.html">Re: Fact-checking a claim about relay/bridge fingerprint authentication</a>
</aside>

<p id=p86>
A&nbsp;client-chooses design risks misuse, if&nbsp;not handled carefully.
Clients must not be able to
cause proxies to connect to arbitrary destinations—otherwise
proxies might be used in denial-of-service attacks, for example.<a class=mark href=#n-52>&bull;</a>
To&nbsp;enforce this restriction,
the client indicates its choice of bridge
not by an IP address or hostname,
but by an identity public key.
The broker maps the identity to a WebSocket URL
using its own database of known bridges,
and rejects rendezvous messages that ask for an unknown bridge<a class=mark href=#n-53>&bull;</a>.
After the broker tells the proxy what WebSocket URL to connect&nbsp;to<a class=mark href=#n-54>&bull;</a>,
the proxy does its own check,
verifying that the hostname in the URL has
a known suffix reserved for Snowflake bridges.
So&nbsp;there are two independent safeguards against misuse.
</p>

<aside class=note id=n-52>
<ul>
<li><a href="https://forum.torproject.net/t/anyone-experiencing-problems-with-snowflake-proxy/6938/15">“Clients cannot cause a proxy to attack or even connect to an arbitrary web site or relay…”</a></li>
<li>An alternative vision: <a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40248">(More) Distributed servers</a></li>
<li>Flash proxy discussion: <a href="https://bugs.torproject.org/legacy/trac/10196">“Allow the client to pick a specific relay for its registration”</a></li>
<li>Flash proxy: <a href="https://gitlab.torproject.org/tpo/anti-censorship/pluggable-transports/flashproxy/-/compare/7c7acc14638a3e9346c99defa6d4dd80b4f437aa...d518f2615d977475dabaf4a46fbbe83c5a52801c">Remove “facilitator”, “client”, “relay” query string parameters. … These could be used to send unsolicited WebSocket connection attempts.</a></li>
</ul>
</aside>

<aside class=note id=n-53>
<a href="https://gitlab.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/-/blob/8e5ea8261110e97a8df56cfc9c83028081d902fb/broker/ipc.go#L187"><code>GetBridgeInfo(BridgeFingerprint)</code></a>
</aside>

<aside class=note id=n-54>
<a href="https://gitlab.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/-/blob/8e5ea8261110e97a8df56cfc9c83028081d902fb/broker/ipc.go#L144"><code>EncodePollResponseWithRelayURL</code></a>
</aside>

</section>

<!--
<section>
<h3>SQL injection attempts at broker</h3>
<p id=p87>
https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40089
Actually tailored to the broker protocol, not a generic attack tool.
</p>
</section>
-->

</section>

<section id=block data-number=5>
<h2><a href=#block><span class=number>5</span> Notable blocking attempts</a></h2>

<p id=p88>
In&nbsp;<a href=#clients>Section&nbsp;4.1</a> we saw how Snowflake’s user counts
have at times been affected by the blocking actions of censors.
Now we take a closer look at selected censorship events.
The effect of censorship has usually been to increase, rather than decrease,
the number of Snowflake users.
This is no paradox:
as&nbsp;censorship intensifies,
users are displaced from less resilient
to more resilient systems.
Snowflake’s blocking resistance has not always been a success,
though, and here we also reflect on missteps
and persistent challenges.
The examples are taken from
Russia, Iran, China, and Turkmenistan,
and are selected for being significant and instructive.
Common lessons are that communication
with affected users is invaluable in quickly understanding and reacting to blocking;
and that blocking resistance needs to be understood
relative to a censor,
because every censor’s cost calculus is different.
</p>

<p id=p89>
Client count estimates come from the
Tor Metrics descriptors described in <a href=#clients>Section&nbsp;4.1</a>.
Country code assignments are drawn from the same IP geolocation database
used by ordinary Tor relays and bridges—and
the caveats of IP geolocation apply to the per-country estimates in this section.
In&nbsp;particular, we&nbsp;have noticed that a fraction of clients
that geolocate to the United States are likely actually to be in Iran,
based on correlations of their dynamics with those of other clients that geolocate to Iran,
and the timing of known political events.<a class=mark href=#fn-32><sup>32</sup></a>
The graphs of this section use raw geolocation results,
with no attempt to adjust for errors.
</p>

<aside class=footnote id=fn-32>
<sup>32</sup>
<a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40207#note_2844116">“I have a new working hypothesis: the sudden decline <em>is</em> caused by a partial block of the broker in Iran.”</a>
</aside>

<p id=p90>
Snowflake is blockable by any censor that is willing to block WebRTC.
We&nbsp;would not try to argue otherwise.
Indeed, we&nbsp;believe that the way to present a circumvention system is
not to argue for its absolute unblockability,
but to lay out
what actions by a censor would be necessary to block&nbsp;it—or&nbsp;more
to the point,
<em>what sacrifices a censor would have to make</em>
in order to block&nbsp;it.
Advancing the state of the art of censorship circumvention
consists in pushing blocking
out of reach of more and more censors.
</p>

<section id=block-ru data-number=5.1>
<h3><a href=#block-ru><span class=number>5.1</span> Blocking in Russia</a></h3>

<figure id=fig-client-counts-ru data-number=8>
<picture>
<source srcset=users-ru.svg type="image/svg+xml" width=1000 height=375>
<img src=users-ru.png width=1000 height=375>
</picture>
<figcaption>
<a href=#fig-client-counts-ru>Figure&nbsp;8</a>:
Snowflake users in Russia (average concurrent).
Events discussed in the text are marked.
The attempted blocking of Tor-related transports in <time datetime=2021-12>December&nbsp;2021</time>
led to Snowflake’s first surge in usage.
The decrease in <time datetime=2022-09>September</time>–<time datetime=2022-10>October&nbsp;2022</time>
coincided with an even larger influx from Iran.
</figcaption>
</figure>

<p id=p91>
Snowflake, along with other common ways of accessing Tor,
was blocked in a subset of ISPs in Russia
on <time>2021-12-01</time>&nbsp;<a href=#ref:ooni-2021-russia-blocks-tor class=cite>[<span class=number>44</span>]</a><a class=mark href=#n-55>&bull;</a>.
The event was evidently coordinated and targeted,
as&nbsp;it happened suddenly and affected many Tor-related protocols at once.
Besides Snowflake,
a&nbsp;portion of Tor relays and bridges,
as&nbsp;well as some servers of
the circumvention transports meek and obfs4,
were blocked, at&nbsp;least temporarily.
The blocking campaign was
less than totally successful—one
of its effects was to substantially increase the number
of users accessing Tor via circumvention transports,
Snowflake among them.<a class=mark href=#n-56>&bull;</a>
<!--
That pluggable transports could not compensate fully
for the loss of relay users points to a usability gap.
-->
</p>

<aside class=note id=n-55>
<ul>
<li><a href="https://bugs.torproject.org/tpo/community/support/40050">[Russia] Some ISPs are blocking Tor</a></li>
<li><a href="https://blog.torproject.org/tor-censorship-in-russia/">Responding to Tor censorship in Russia</a></li>
<li><a href="https://ntc.party/t/ooni-reports-of-tor-blocking-in-certain-isps-since-2021-12-01/1477/95">“Tor filtering is done
using government black box called TSPU. Not all providers have them. Tor is not blocked if TSPU is not present.
According to tor metrics graph directly connecting users decreased only by 1/3.
This indicates TSPU is not everywhere.”</a></li>
</ul>
</aside>

<aside class=note id=n-56>
<a href="https://bugs.torproject.org/tpo/community/support/40050#note_2796770">“A zoom on just the bridge transports”</a>
</aside>

<p id=p92>
We&nbsp;benefited from established relationships
with developers and users in Russia,
one of whom, through manual testing,
found the traffic feature that was being used to distinguish Snowflake.
It&nbsp;was DTLS fingerprinting<a class=mark href=#fn-33><sup>33</sup></a>,
of&nbsp;the kind cautioned about in <a href=#fingerprinting>Section&nbsp;3</a>.
Specifically, it&nbsp;was the presence of a
supported_groups extension in the DTLS Server Hello message produced by Pion.
The extension’s presence in Server Hello was in fact a bug<a class=mark href=#fn-34><sup>34</sup></a>—but
in any case, it afforded the censor a feature
to distinguish DTLS connections with a Pion implementation in the server role
from other forms of DTLS.
The process of finding the flaw, fixing it,
and shipping new releases of Tor Browser took a few weeks<a class=mark href=#fn-35><sup>35</sup></a>,
after which the user count rose rapidly.
From the beginning to the end of <time datetime=2021-12>December&nbsp;2021</time>,
the number of users in Russia grew from about 400 to over 4,000
(<a href=#fig-client-counts-ru>Figure&nbsp;8</a>)<a class=mark href=#calc-16>&bull;</a>.
Snowflake was to become a significant tool
amid the general intensification of censorship in Russia
following the invasion of Ukraine in <time datetime=2022-02>February&nbsp;2022</time>.
</p>

<aside class=footnote id=fn-33>
<sup>33</sup>
<a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40014#note_2765074">Russian DPI check supported_groups extension in ServerHello payload (byte 0x5a in udp packet)</a>
</aside>

<aside class=footnote id=fn-34>
<sup>34</sup>
<a href="https://github.com/pion/dtls/issues/409">Server Hello should not contain supported_groups extension (extension.SupportedEllipticCurves)</a>
</aside>

<aside class=footnote id=fn-35>
<sup>35</sup>
<ul>
<li><a href="https://gitlab.torproject.org/tpo/applications/tor-browser-build/-/merge_requests/375">Point to a forked version of pion/dtls with fingerprinting fix</a></li>
<li><a href="https://blog.torproject.org/new-release-tor-browser-115a1/">New Alpha Release: Tor Browser 11.5a1 (Windows, macOS, Linux)</a></li>
<li><a href="https://blog.torproject.org/new-release-tor-browser-1103/">New Release: Tor Browser 11.0.3</a></li>
</ul>
</aside>

<aside class=calc id=calc-16>
<details>
<summary>Calculation</summary>
<pre><samp>&gt; <kbd>library("tidyverse")</kbd>
&gt; WANTED_FINGERPRINTS &lt;- c(
    "7659DA0F96B156C322FBFF3ACCC9B9DC01C27C73" = "snowman",
    "5481936581E23D2D178105D44DB6915AB06BFB7F" = "snowflake-01",
    "91DA221A149007D0FD9E5515F5786C3DD07E4BB0" = "snowflake-02"
  )
&gt; userstats &lt;- read_csv("figures/users/userstats-bridge-combined-multi.csv") %&gt;%
    filter(transport == "snowflake" &amp; fingerprint %in% names(WANTED_FINGERPRINTS)) %&gt;%
    mutate(across(c(low, high), &amp;nbsp; .x / (coverage / pmax(num_instances, coverage)))) %&gt;%
    mutate(users = (low + high) / 2) %&gt;%
    # Combine the contributions of all bridges.
    group_by(date, transport, country) %&gt;% summarize(across(c(low, high, users), sum), .groups = "drop") %&gt;%
    # Apportion "??" to other countries (see figures/users/users-country.r).
    group_by(date, transport) %&gt;% mutate(across(c(low, high, users), &amp;nbsp; .x * sum(.x) / sum(ifelse(country == "??", 0, .x)))) %&gt;% ungroup() %&gt;% filter(country != "??")
&gt; userstats %&gt;% filter(date %in% as.Date(c("2021-12-01", "2022-01-01"))) %&gt;% filter(country == "ru")
# A tibble: 2 x 6
  date       transport country   low  high users
  &lt;date&gt;     &lt;chr&gt;     &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
1 2021-12-01 snowflake ru       381.  381.  381.
2 2022-01-01 snowflake ru      4381. 4380. 4380.
</samp></pre>
</details>
</aside>

<p id=p93>
The Server Hello supported_groups distinguisher
had been
discovered and documented by MacMillan et&nbsp;al.&nbsp;<a href=#ref:arxiv.2008.03254 class=cite>[<span class=number>22</span>&nbsp;§3]</a>
already in&nbsp;<time>2020</time>.
We&nbsp;might have avoided this blocking event by proactively fixing
the known distinguisher—but
it was not necessarily the wrong call not to have done&nbsp;so.
In&nbsp;a project like Snowflake,
there is always more to do than time to do&nbsp;it,
and one must consider the opportunity cost
of preempting specific blocking that may not come to pass.
In&nbsp;this case, a&nbsp;reactive approach by us was enough:
the loss was minor, and we were able to patch the problem quickly.
Even in ISPs where the blocking rule was present,
it&nbsp;did not block 100% of Snowflake connections,
because of the way it targeted a quirk in Pion,
and only in Server Hello.
When the DTLS server role in the WebRTC data channel
was played by a non-Pion peer,
such as a web browser proxy,
the feature was not present.
<!--
The Snowflake client would retry its rendezvous repeatedly,
until hitting on a proxy that worked.
-->
</p>

<!--
"Snowflake blocked by ClientHello [RU]" https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40140
-->

<p id=p94>
In&nbsp;<time datetime=2022-05>May 2022</time> we got a report of a new detection rule,
this time keying on not just the presence, but the <em>contents</em>
of the supported_groups extension,
at&nbsp;a byte offset suggesting that
it now targeted the Client Hello message,
not Server Hello.<a class=mark href=#fn-36><sup>36</sup></a>
The presence of a supported_groups extension in Client Hello is not unusual,
but the specific groups offered by Pion’s implementation
differed from those of common browsers.
Though we confirmed the existence of the blocking rule,
testers reported that Snowflake continued to work<a class=mark href=#n-57>&bull;</a>—which
may have something to do with the fact that the Snowflake client
does not always play the client role in DTLS.
If&nbsp;the Snowflake client is the DTLS server,
and the DTLS client is a browser proxy,
then the byte pattern looked for by the blocking rule does not appear.
<!--
Hard to say at this point, but perhaps it was the cause of the sharp drop in April 2022, only reported in May?
-->
We&nbsp;developed a mitigation,
but by the time we prepared a testing release in <time datetime=2022-07>July&nbsp;2022</time><a class=mark href=#n-58>&bull;</a>,
the new rule
had apparently been removed
and replaced by another.
We&nbsp;can only speculate as to why,
but it may be that the old rule
had too many false positives,
or&nbsp;simply was not effective enough.
</p>

<aside class=footnote id=fn-36>
<sup>36</sup>
<a href="https://bugs.torproject.org/tpo/anti-censorship/censorship-analysis/40030">IRC Tip about Signature used to block Snowflake in Russia, <time datetime=2023-05-16>2022-May-16</time></a>
</aside>

<aside class=note id=n-57>
<a href="https://ntc.party/t/a-new-snowflake-blocking-rule-offset-of-supported-groups-in-dtls-client-hello/2420/2">“Snowflake works fine, as it used to.”</a>
</aside>

<aside class=note id=n-58>
<ul>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/team/83">Creating a version of Tor Browser with patched Snowflake client that includes supported_groups censorship countermeasure</a></li>
<li><a href="https://ntc.party/t/testing-invitation-for-tor-browser-with-supported-groups-patch-countermeasure-in-snowflake-to-evade-censorship-observed-in-russia/2837">Testing Invitation for Tor Browser with supported_groups patch countermeasure in Snowflake to evade censorship observed in Russia</a></li>
</ul>
</aside>

<p id=p95>
The detection rule that replaced supported_groups in Client Hello
looked for the server sending a Hello Verify Request message.<a class=mark href=#fn-37><sup>37</sup></a>
Hello Verify Request is an anti-denial-of-service feature in DTLS,
in&nbsp;which the server sends a random cookie to the client,
and the client sends a second Client Hello message,
this time containing a copy of the cookie&nbsp;<a href=#ref:rfc9147 class=cite>[<span class=number>32</span>&nbsp;§5.1]</a>.
It&nbsp;is not an error to send Hello Verify Request
(it&nbsp;is a “MAY” in the RFC),
but because the Pion implementation in Snowflake sent&nbsp;it,
and major browsers did not,
it was a reliable indicator of Snowflake connections.
(At least, those in which
a Snowflake client or command-line proxy
took the DTLS server role.)
This distinguisher, too, had been anticipated by
MacMillan et&nbsp;al. in 2020&nbsp;<a href=#ref:arxiv.2008.03254 class=cite>[<span class=number>22</span>&nbsp;§3]</a>.
The first reports of this blocking rule arrived in <time datetime=2022-07>July&nbsp;2022</time>;
but as you can see in <a href=#fig-client-counts-ru>Figure&nbsp;8</a>,
it&nbsp;had no apparent immediate effect.
It&nbsp;is hard to say whether the drastic decline in <time datetime=2022-10>October 2022</time>
was a consequence of this rule,
or&nbsp;some other, unidentified one.
That decline coincided with an enormous increase of users from Iran,
which temporarily affected the usability of the whole system.
We&nbsp;deployed a mitigation to remove the Hello Verify Request message
from Snowflake, regrettably, only in <time datetime=2023-02>February&nbsp;2023</time>&#x202f;<a class=mark href=#fn-38><sup>38</sup></a>,
after which the number of users in Russia began to recover.<a class=mark href=#n-59>&bull;</a>
</p>

<aside class=footnote id=fn-37>
<sup>37</sup>
<a href="https://bugs.torproject.org/tpo/anti-censorship/censorship-analysis/40030#note_2823140">“They removed the blocking of Client Hello, now they block Hello Verify Request”</a>
</aside>

<aside class=footnote id=fn-38>
<sup>38</sup>
<a href="https://gitlab.torproject.org/tpo/applications/tor-browser-build/-/merge_requests/637">Apply Snowflake Remove HelloVerify Countermeasure</a>
(and only in Tor Browser, no Orbot yet)
</aside>

<aside class=note id=n-59>
<a href="https://bugs.torproject.org/tpo/anti-censorship/censorship-analysis/40030#note_2893870">“Since the release of Tor Browser 12.0.3 on <time>2023-02-15</time> there has been an increase in users from Russia on both bridges.”</a>
</aside>

<!--
"OONI shows blocking of Snowflake in select ISPs in Russia since 2023-02" https://ntc.party/t/ooni-shows-blocking-of-snowflake-in-select-isps-in-russia-since-2023-02
Caused by out-of-date ooni-probe.
-->

<p id=p96>
The case of Snowflake in Russia illustrates
some of the complexity of censorship measurement.
The&nbsp;answer to a question like “Does Snowflake work in Russia?”
is not always a simple yes or&nbsp;no.
It&nbsp;may depend on the date, the ISP,
and even details such as which endpoint plays the DTLS server role.
</p>

</section>

<section id=block-ir data-number=5.2>
<h3><a href=#block-ir><span class=number>5.2</span> Blocking in Iran</a></h3>

<figure id=fig-client-counts-ir data-number=9>
<picture>
<source srcset=users-ir.svg type="image/svg+xml" width=1000 height=375>
<img src=users-ir.png width=1000 height=375>
</picture>
<figcaption>
<a href=#fig-client-counts-ir>Figure&nbsp;9</a>:
Snowflake users in Iran.
Heightened censorship beginning in <time datetime=2022-09>September 2022</time>
caused Iran to become the single biggest source of Snowflake users.
The drop in <time datetime=2022-10>October 2022</time>
was the result of TLS fingerprint blocking,
which interfered with rendezvous
and took some time to mitigate.
</figcaption>
</figure>

<p id=p97>
In&nbsp;late <time datetime=2022-09>September 2022</time>,
users from Iran became the majority of Snowflake users almost overnight,
only to fall just as quickly two weeks later.<a class=mark href=#n-60>&bull;</a>
See <a href=#fig-client-counts-ir>Figure&nbsp;9</a>.
The cause of the rise was
extraordinary new network restrictions amid mass protests&nbsp;<a href=#ref:ooni-2022-iran-blocks-social-media-mahsa-amini-protests class=cite>[<span class=number>3</span>]</a>;
the cause of the decline was TLS fingerprint blocking,
which stopped Snowflake rendezvous from working.
The crypto/tls package of the Go programming language
(in&nbsp;which the Snowflake client is written)
may produce several slightly different TLS fingerprints,
depending on hardware capabilities and how it is compiled.<a class=mark href=#fn-39><sup>39</sup></a>
It&nbsp;was one of these fingerprints that was blocked.
Because the blocking rule was specific to one fingerprint,
only some users were affected.<a class=mark href=#n-61>&bull;</a>
Why would a censor block only one (even if the most common)
of several TLS fingerprints?
It&nbsp;may have been a simple oversight.
On&nbsp;the other hand, it&nbsp;is not certain that this instance of TLS fingerprinting
in Iran
was meant for Snowflake specifically.
Go&nbsp;is a popular language for implementing circumvention systems;
Snowflake may have been caught up in blocking that was intended for another system.
</p>

<aside class=note id=n-60>
<ul>
<li><a href="https://github.com/net4people/bbs/issues/131">Unexplained drop in Snowflake client polls and bandwidth, testers wanted</a></li>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/team/96#note_2840481">Tor censorship in Iran</a></li>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40207">Sudden reduction in snowflake-01 bridge bandwidth, <time>2022-10-04 17:15</time></a></li>
<!--
"Planning response to censorship in Iran with AC team" https://gitlab.torproject.org/tpo/team/-/wikis/Planning-response-to-censorship-in-Iran-with-AC-team
-->
</ul>
</aside>

<aside class=footnote id=fn-39>
<sup>39</sup>
<ul>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40207#note_2844163">“…in native Go crypto/tls fingerprints since go1.17 is that the order of ciphersuites depends on whether the platform has support for accelerated AES-GCM”</a></li>
<li><a href="https://github.com/net4people/bbs/issues/125#issuecomment-1284602875">“There is strong evidence of an attempt to block the native Go crypto/tls fingerprint, but not all native fingerprints produced by Go programs are blocked.”</a></li>
</ul>
</aside>

<aside class=note id=n-61>
<ul>
<li><a href="https://github.com/net4people/bbs/issues/139#issuecomment-1280243079">“This all gives us a good hypothesis… It includes the fingerprints of go1.17+ crypto/tls without AES acceleration”</a></li>
<li><a href="https://github.com/net4people/bbs/issues/131#issuecomment-1280284051">“When I tested the desktop version, I did it in a VM that did not emulate support for accelerated AES-GCM…”</a></li>
</ul>
</aside>

<p id=p98>
The fact that simple TLS fingerprinting worked to block Snowflake rendezvous
was carelessness on our part.
Having been aware of the possibility,
we&nbsp;previously implemented TLS camouflage
in the Snowflake client using uTLS<a class=mark href=#n-62>&bull;</a>—but
failed to turn it on by default.
Activating the feature required only a small configuration change<a class=mark href=#fn-40><sup>40</sup></a>,
but we had to wait for new releases of Tor Browser and Orbot
to get it into the hands of users:
see the <time datetime=2022-09>September</time>–<time datetime=2022-11>November&nbsp;2022</time> interval in <a href=#fig-client-counts-ir>Figure&nbsp;9</a>.
<!--
A report of a Chrome 107.0.5304.88 TLS fingerprint (used by actual Chrome and apparently also by uTLS)
being blocked in Mokhaberat and Irancell between 2022-11-06 and 2022-02-16.
https://github.com/net4people/bbs/issues/153
https://github.com/net4people/bbs/issues/153#issuecomment-1354805098
-->
</p>

<aside class=note id=n-62>
<a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40054">uTLS for broker negotiation</a>
</aside>

<aside class=footnote id=fn-40>
<sup>40</sup>
<a href="https://gitlab.torproject.org/tpo/applications/tor-browser-build/-/merge_requests/540">Enable uTLS and use the full bridge line for snowflake</a>
</aside>

<p id=p99>
After we repaired the TLS fingerprinting flaw,
the number of users from Iran gradually recovered
to near its former peak.
We&nbsp;are aware of only minor disruptions after this time.
The default rendezvous front domain
was blocked (by&nbsp;TLS SNI) in some ISPs
between <time>2023-01-16</time> and <time>2023-01-24</time>&#x202f;<a class=mark href=#fn-41><sup>41</sup></a>,
which we confirmed using data from the censorship measurement platform OONI.
A&nbsp;reduction in users is visible at this time.
AMP cache rendezvous continued to work.
OONI measurements in the weeks after the block was lifted showed additional sporadic
failures to connect to the front domain.
If&nbsp;these were further attempts at blocking,
they did not have much of an effect.
</p>

<aside class=footnote id=fn-41>
<sup>41</sup>
<a href="https://bugs.torproject.org/tpo/anti-censorship/team/115#note_2873040">Blocking of cdn.sstatic.net by SNI in Iran, 2023-01-16 to 2023-01-24 and sporadically thereafter</a>
</aside>

</section>

<section id=block-cn data-number=5.3>
<h3><a href=#block-cn><span class=number>5.3</span> Blocking in China</a></h3>

<figure id=fig-client-counts-cn data-number=10>
<picture>
<source srcset=users-cn.svg type="image/svg+xml" width=1000 height=375>
<img src=users-cn.png width=1000 height=375>
</picture>
<figcaption>
<a href=#fig-client-counts-cn>Figure&nbsp;10</a>:
Snowflake users in China.
Though no sustained blocking is evident,
disruption of domain fronting rendezvous
for three days in <time datetime=2023-05>May 2023</time> briefly
depressed user numbers.
</figcaption>
</figure>

<p id=p100>
The graph of users from China,
<a href=#fig-client-counts-cn>Figure&nbsp;10</a>,
does not show any drastic changes
like those we have seen so far.
There is a modest but respectable number of Snowflake users in China.
Though there has been no sustained interference,
we&nbsp;have seen some evidence of short-term or tentative
blocking attempts.
</p>

<p id=p101>
In&nbsp;<time datetime=2019-05>May 2019</time>, when Snowflake was still in alpha release,
a&nbsp;user in China reported a failure to connect.
Investigation revealed that the cause was blocking of the IP address of
the few proxies that existed at the time.<a class=mark href=#fn-42><sup>42</sup></a>
The STUN exchange worked,
and rendezvous completed successfully,
but the client and proxy could not establish a connection.
We&nbsp;experimented with running a proxy
at a previously unused IP address:
clients in China could connect when they were assigned
that proxy by the broker.
This was before the web browser extension proxy existed,
when the only consistent proxy support was a few standalone proxies
running at a static IP address.
It&nbsp;stopped being a problem as the proxy pool grew in size.
</p>

<aside class=footnote id=fn-42>
<sup>42</sup>
<a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/30350#note_2593274">“I’m going to say that this a proxy blocking problem”</a>
</aside>

<p id=p102>
That same month, we noticed blocking of
the default STUN server,
of which there was only one at the time.<a class=mark href=#fn-43><sup>43</sup></a>
The solution was to add more STUN servers<a class=mark href=#fn-44><sup>44</sup></a>,
and select a subset of them on each rendezvous attempt<a class=mark href=#fn-45><sup>45</sup></a>.
Curiously, it seems that when the STUN server was blocked,
the standalone proxies that had been blocked earlier in the month became unblocked.<a class=mark href=#fn-46><sup>46</sup></a>
</p>

<aside class=footnote id=fn-43>
<sup>43</sup>
<ul>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/30368#note_2593357">“Access to stun.l.google.com:19302 was blocked”</a></li>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/30350#note_2593299">“It looks like the initial connection to the default STUN server is being blocked”</a></li>
<li><a href="https://gitlab.torproject.org/tpo/applications/tor-browser-build/-/blob/4ff2be0b02e322716f06829e49c50f39795bf43c/projects/tor-browser/Bundle-Data/PTConfigs/linux/torrc-defaults-appendix#L5"><code>-ice stun:stun.l.google.com:19302</code></a></li>
</ul>
</aside>

<aside class=footnote id=fn-44>
<sup>44</sup>
<ul>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/30579">Add more STUN servers to the default snowflake configuration in Tor Browser</a></li>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/30350#note_2723004">“As far as we know, setting new STUN servers unblocked Snowflake in China.”</a></li>
</ul>
</aside>

<aside class=footnote id=fn-45>
<sup>45</sup>
<a href="https://gitlab.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/-/merge_requests/7">Choose a random subset from given STUN servers</a>
</aside>

<aside class=footnote id=fn-46>
<sup>46</sup>
<ul>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/30368#note_2593360">“It seems once they blocked those stun servers, all snowflake bridges became reachable again.”</a></li>
<li>NB stun.l.google.com <a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40044#note_2734125">reported reachable</a> (to ICMP at least) <time>2021-05-03</time>
</ul>
</aside>

<!--
2019-12-02 "Investigate Snowflake blocking in China" https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/32657

These were determined not to be GFW related, rather proxy bugs:
2019-08-25 "Hello, currently, in China, I can’t open any webpage in 9.0a4 version Tor browser through snowflake bridge" https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/31503
2019-09-22 "Hello, today after about two hours, I can’t open any webpage in Tor browser through Snowflake bridge." https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/31818
2019-10-02 "Hello, Currently, Tor Browser 9.0a7 can’t connect to Tor network through Snowflake bridge." https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/31930
2019-10-04 "Hello, currently, in China, Tor Browser 9.0a7 version can’t establish a Tor network connection through snowflake bridge" https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/31960
2019-12-01 "Yesterday, in China, I tried to connect to Tor network through snowflake bridge for 10 times. But all of the connections failed" https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/32653
2019-12-21 "Hello, currently, in China, Tor Browser 9.5a3 still can’t connect to Tor network through snowflake bridge." https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/32833
2020-01-13 "Hello, currently, in China, Tor Browser 9.5a4 still can’t connect to Tor network through snowflake bridge." https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/32930

Attributed to lack of Turbo Tunnel:
2019-11-25 "Hello, currently, in China, Tor Browser 9.5a2 still can’t connect to Tor network through snowflake bridge" https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/32597
2020-03-29 "Hello, currently, in China, Tor Browser 9.5a8 still can’t connect to Tor network through snowflake bridge." https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/33756

Unresolved/needs information:
2021-05-03 "Hello, currently, in China, tor-browser-linux64-10.5a15 can not connect to Tor network through Snowflake bridge" https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40044
-->

<p id=p103>
The next incidents we are aware of did not occur until 2023.
On <time datetime=2023-05-12>May&nbsp;12</time>, <time datetime=2023-05-12>13</time>, and&nbsp;<time datetime=2023-05-12>14</time>, a&nbsp;few users reported problems
with domain fronting rendezvous.<a class=mark href=#fn-47><sup>47</sup></a>
We&nbsp;could not get systematic measurements,
but it appeared that censorship was triggered
by observing multiple (two or three) HTTPS connections
with the same TLS SNI to certain IP addresses within a short time.
It&nbsp;is possible that Snowflake was not the target of this
blocking behavior, and was affected only as a side effect.
If&nbsp;it indeed had to do with Snowflake,
our best guess is that it was aimed at rendezvous with multiple bridges
(<a href=#multi-bridge>Section&nbsp;4.4</a>), though such a
policy would certainly also affect a large number of non-Snowflake connections.
The user count from China was about halved during those three days,
an&nbsp;effect that is visible in <a href=#fig-client-counts-cn>Figure&nbsp;10</a>.
On&nbsp;<time>2023-05-15</time>, the blocking went away and the user count returned to what it had been.<a class=mark href=#n-63>&bull;</a>
</p>

<aside class=footnote id=fn-47>
<sup>47</sup>
<ul>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/censorship-analysis/40038">Blocking of Snowflake in China, <time>2023-05-12</time></a></li>
<li><a href="https://github.com/net4people/bbs/issues/249">Confirmed block of default Snowflake in China</a></li>
<li><a href="https://forum.torproject.net/t/snowflake-bridge-does-not-work-in-china-since-days-ago/7635">Snowflake bridge does not work in China since days ago</a></li>
</ul>
</aside>

<aside class=note id=n-63>
Reported at the same time, perhaps coincidental:
<a href="https://github.com/net4people/bbs/issues/248">GFW at the Edge: Latest Development of China’s Distributed Censorship System</a>
</aside>

<p id=p104>
Also in <time datetime=2023-05>May 2023</time>, one user reported apparent throttling
(artificial reduction in speed by packet dropping)
of&nbsp;TLS-in-DTLS connections,
based on packet size and timing features.<a class=mark href=#fn-48><sup>48</sup></a>
Such a policy would affect Snowflake,
because of the fact that it transports Tor TLS inside DTLS data channels.
Reportedly,
padding the first few packets
would prevent throttling
(a&nbsp;possible counterexample to our claims about traffic analysis in <a href=#fingerprinting>Section&nbsp;3</a>).
Our own speed tests run at the time
did not show evidence of throttling,
with or without added padding.<a class=mark href=#fn-49><sup>49</sup></a>
There was no obvious reduction in the number of users.
It&nbsp;may have been a localized, ISP-specific phenomenon.
</p>

<aside class=footnote id=fn-48>
<sup>48</sup>
<a href="https://github.com/net4people/bbs/issues/255">Potential TLS-over-DTLS blocking in China</a>
</aside>

<aside class=footnote id=fn-49>
<sup>49</sup>
<a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40251#note_2906723">Analysis of speed deficiency of Snowflake in China, 2023 Q1</a>
</aside>

<!--
Slowness, great bottleneck?
-->

</section>

<section id=block-tm data-number=5.4>
<h3><a href=#block-tm><span class=number>5.4</span> Blocking in Turkmenistan</a></h3>

<figure id=fig-client-counts-tm data-number=11>
<picture>
<source srcset=users-tm.svg type="image/svg+xml" width=1000 height=375>
<img src=users-tm.png width=1000 height=375>
</picture>
<figcaption>
<a href=#fig-client-counts-tm>Figure&nbsp;11</a>:
Snowflake users in Turkmenistan.
This graph shows an earlier range of dates than the other three.
Though there have never been many Snowflake users in Turkmenistan,
blocking events are evident on
<time>2021-10-24</time> and <time>2022-08-03</time>.<a class=mark href=#calc-15>&bull;</a>
</figcaption>
</figure>

<aside class=calc id=calc-15>
<details>
<summary>Calculation</summary>
<pre><samp>&gt; <kbd>library("tidyverse")</kbd>
&gt; <kbd>WANTED_FINGERPRINTS &lt;- c(
    "7659DA0F96B156C322FBFF3ACCC9B9DC01C27C73" = "snowman",
    "5481936581E23D2D178105D44DB6915AB06BFB7F" = "snowflake-01",
    "91DA221A149007D0FD9E5515F5786C3DD07E4BB0" = "snowflake-02"
  )</kbd>
&gt; <kbd>userstats &lt;- read_csv("figures/users/userstats-bridge-combined-multi.csv") %&gt;%
    filter(transport == "snowflake" &amp; fingerprint %in% names(WANTED_FINGERPRINTS)) %&gt;%
    mutate(across(c(low, high), &amp;nbsp; .x / (coverage / pmax(num_instances, coverage)))) %&gt;%
    mutate(users = (low + high) / 2) %&gt;%
    # Combine the contributions of all bridges.
    group_by(date, transport, country) %&gt;% summarize(across(c(low, high, users), sum), .groups = "drop") %&gt;%
    # Apportion "??" to other countries (see figures/users/users-country.r).
    group_by(date, transport) %&gt;% mutate(across(c(low, high, users), &amp;nbsp; .x * sum(.x) / sum(ifelse(country == "??", 0, .x)))) %&gt;% ungroup() %&gt;% filter(country != "??") %&gt;%
    filter(country == "tm")</kbd>
&gt; <kbd>userstats %&gt;% filter("2021-10-20" &lt;= date &amp; date &lt;= "2021-10-28")</kbd>
&gt; <kbd>userstats %&gt;% filter("2022-07-30" &lt;= date &amp; date &lt;= "2022-08-07")</kbd>
# A tibble: 9 × 6
  date       transport country   low  high users
  &lt;date&gt;     &lt;chr&gt;     &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
1 2021-10-20 snowflake tm      33.0  33.1  33.0
2 2021-10-21 snowflake tm      27.3  27.8  27.5
3 2021-10-22 snowflake tm      23.1  23.6  23.4
4 2021-10-23 snowflake tm      18.9  19.5  19.2
5 2021-10-24 snowflake tm       5.56  6.19  5.87
6 2021-10-25 snowflake tm       1.63  2.23  1.93
7 2021-10-26 snowflake tm       2.12  2.64  2.38
8 2021-10-27 snowflake tm       1.29  1.40  1.35
9 2021-10-28 snowflake tm       1.05  1.72  1.39
# A tibble: 9 × 6
  date       transport country   low   high users
  &lt;date&gt;     &lt;chr&gt;     &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;
1 2022-07-30 snowflake tm       6.29  7.92  7.11
2 2022-07-31 snowflake tm       5.66  7.76  6.71
3 2022-08-01 snowflake tm       8.43 10.6   9.51
4 2022-08-02 snowflake tm       3.03  5.25  4.14
5 2022-08-03 snowflake tm       0     1.47  0.735
6 2022-08-04 snowflake tm       0     1.24  0.618
7 2022-08-05 snowflake tm       0     1.32  0.659
8 2022-08-06 snowflake tm       0     0.619 0.310
9 2022-08-07 snowflake tm       0     0.771 0.386
</samp></pre>
</details>
</aside>

<p id=p105>
There have never been more than a few tens of Snowflake users in Turkmenistan.
Even so, it&nbsp;has happened at least twice
that the number of users dropped suddenly to zero,
as&nbsp;shown in <a href=#fig-client-counts-tm>Figure&nbsp;11</a>.
We&nbsp;found a variety of causes:
domain name blocking
by DNS and TCP RST injection,
and blocking of certain UDP port numbers
commonly used for STUN.
</p>

<p id=p106>
Turkmenistan is a particularly challenging environment for circumvention.
Though relatively unsophisticated, the censorship there
is more severe and indiscriminate
than in the other places we have discussed.
Only a small fraction of the population has access to the Internet at all,
which makes it hard to communicate with volunteer testers
and lengthens testing cycles.
We&nbsp;have been able to mitigate Snowflake blocking in Turkmenistan,
but only partially, and after protracted effort.
</p>

<p id=p107>
The drop on <time>2021-10-24</time> was caused by
blocking of the default broker front domain.<a class=mark href=#fn-50><sup>50</sup></a>
We&nbsp;determined this by
taking advantage of the bidirectionality of the Turkmenistan firewall.
Nourin et&nbsp;al.&nbsp;<a href=#ref:Nourin2023a class=cite>[<span class=number>25</span>&nbsp;§2]</a> provide more details;
here we will state just the essentials.
Among the censorship techniques used in Turkmenistan
are DNS response injection and TCP RST injection.
DNS queries for filtered hostnames receive an injected response
containing a false IP address;
TLS handshakes with a filtered SNI receive an injected TCP RST packet
that tears down the connection.
Conveniently for analysis,
it&nbsp;works in both directions:
packets that <em>enter</em> the country are subject to injection
just as those that exit it are.<a class=mark href=#n-64>&bull;</a>
By&nbsp;sending probes into the country from outside,
we&nbsp;found that the default broker front domain
was blocked at both the DNS and TLS layers.<a class=mark href=#n-65>&bull;</a>
It&nbsp;was some time—not until <time datetime=2022-08>August 2022</time>—before we got
confirmation from testers that an alternative front domain
worked to get around the block of the broker.<a class=mark href=#n-66>&bull;</a>
<!--
We&nbsp;did not get confirmation whether AMP cache rendezvous also worked,
though our external testing indicated it would.
"it would be helpful to ask them to try the AMP cache rendezvous." https://bugs.torproject.org/tpo/anti-censorship/censorship-analysis/40024#note_2794947
"www.google.com does not appear to be blocked" https://bugs.torproject.org/tpo/anti-censorship/censorship-analysis/40024#note_2767094
-->
</p>

<aside class=footnote id=fn-50>
<sup>50</sup>
<ul>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/censorship-analysis/40024">Blocking of Snowflake in Turkmenistan, <time>2021-10-24</time></a></li>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/censorship-analysis/40029#note_2787789">“On <time>2021-10-24</time>, Snowflake users dropped drastically and thereafter went to zero.”</a></li>
</ul>
</aside>

<aside class=note id=n-64>
<ul>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/censorship-analysis/40029#note_2787781">“I did some tests to see if it would be possible to measure blocking of SNI and DNS from outside Turkmenistan”</a></li>
<li><a href="https://github.com/net4people/bbs/issues/80">Bidirectional DNS, HTTPS, HTTP injection in Turkmenistan</a></li>
</ul>
</aside>

<aside class=note id=n-65>
<a href="https://bugs.torproject.org/tpo/anti-censorship/censorship-analysis/40024#note_2767094">“The block on Snowflake is effected by (at least) DNS and SNI blocking of the broker’s front domain, cdn.sstatic.net.”</a>
</aside>

<aside class=note id=n-66>
<a href="https://bugs.torproject.org/tpo/anti-censorship/censorship-analysis/40024#note_2829121">“broker rendezvous peer received”</a>
</aside>

<!--
This was not the only interference with Tor at the time.
Five days later, on 2021-10-29, Tor users not using circumvention transports
dropped from about 1,000 almost to zero.
https://bugs.torproject.org/tpo/anti-censorship/censorship-analysis/40029#note_2787789
-->

<p id=p108>
The increase in the number of users from <time datetime=2022-05>May</time> to <time datetime=2022-08>August 2022</time>
was caused by
a partial unblocking of the broker front domain on <time>2023-05-03</time>.
We&nbsp;realized this only in retrospect,
after examining data from Censored Planet&nbsp;<a href=#ref:Raman2020c class=cite>[<span class=number>34</span>]</a>,
a&nbsp;censorship measurement platform that, at&nbsp;that time,
had continuous measurements
of the domain from one autonomous system in Turkmenistan.<a class=mark href=#n-67>&bull;</a>
On&nbsp;that date, there was a shift from RST responses to successful TLS connections.
DNS measurements were not available at the moment of the shift,
but they, too, showed no signs of blocking after that date.
Evidently, some users were able to reach the broker, in&nbsp;those days.
But the unblocking must not have been everywhere, because as late as <time>2022-08-18</time>,
users reported that RST injection was still in place for them<a class=mark href=#n-68>&bull;</a>
(though DNS injection had stopped).
</p>

<aside class=note id=n-67>
<p id=p109><a href="https://bugs.torproject.org/tpo/anti-censorship/censorship-analysis/40024#note_2930186">“@agix provided me with Censored Planet measurements of cdn.sstatic.net in Turkmenistan.”</a></p>
<p id=p110>See also figures/turkmenistan/ in this paper’s <a href=#links>source code</a>.
</aside>

<aside class=note id=n-68>
<a href="https://bugs.torproject.org/tpo/anti-censorship/censorship-analysis/40024#note_2829106">“wsarecv: An existing connection was forcibly closed by the remote host.”</a>
</aside>

<!--
Connection Assist
July 2022
https://gitlab.torproject.org/tpo/anti-censorship/rdsys/-/merge_requests/48
-->

<p id=p111>
There was yet another layer to the blocking.
Even if they could contact the broker
(at&nbsp;the default or an alternative front domain),
clients could not then establish a connection with a proxy.<a class=mark href=#n-69>&bull;</a>
Testing revealed blocking of the default STUN port, UDP&nbsp;3478.<a class=mark href=#n-70>&bull;</a>
A&nbsp;client that cannot communicate with a STUN server
cannot find its ICE candidate addresses (<a href=#connection>Section&nbsp;2.2</a>),
without which most WebRTC proxy connections will fail.
(The exceptions are proxies without NAT or ingress filtering.<a class=mark href=#n-71>&bull;</a>
While there are some such proxies,
censorship in Turkmenistan also blocks
large parts of IP address space,
including the data center address ranges where those kinds of proxies tend to run.)
As&nbsp;chance would have it, the NAT behavior discovery feature we rely on
for testing client NATs requires
STUN servers to open a second, functionally equivalent listening socket
on a different port&nbsp;<a href=#ref:rfc5780 class=cite>[<span class=number>21</span>&nbsp;§6]</a>, commonly 3479.
Changing to those alternative port numbers
enabled some users to connect to Snowflake again.<a class=mark href=#n-72>&bull;</a>
Specifically, STUN servers on port 3479 worked in AGTS,
one of two major affected ISPs.
The workaround did not work in Turkmentelecom, the other ISP,
where port&nbsp;3479 was blocked.<a class=mark href=#n-73>&bull;</a>
Though we do not have continuous measurements to be sure<a class=mark href=#n-74>&bull;</a>,
we&nbsp;suspect that the STUN port blocking began on <time>2022-08-03</time>
and is what precipitated the drop seen on that date in <a href=#fig-client-counts-tm>Figure&nbsp;11</a>.
</p>

<aside class=note id=n-69>
<ul>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/censorship-analysis/40024#note_2829140">“There’s some progress in the sense that the broker connection is working now, but it looks like the client is having trouble connecting to the proxies.”</a></li>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/censorship-analysis/40024#note_2829121">“connection failed timeout waiting for DataChannel.OnOpen”</a></li>
</ul>
</aside>

<aside class=note id=n-70>
<a href="https://bugs.torproject.org/tpo/anti-censorship/censorship-analysis/40024#note_2829127">“And port 3478 is blocked in TM”</a>
</aside>

<aside class=note id=n-71>
<a href="https://bugs.torproject.org/tpo/anti-censorship/censorship-analysis/40024#note_2889789">“Even if the user is unable to connect to any STUN servers and sends an SDP offer with no candidates, they should still be able to connect to proxies that are not behind a NAT or behind a full cone NAT”</a>
</aside>

<aside class=note id=n-72>
<ul>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/censorship-analysis/40024#note_2829157">“This line… <code>:3479</code>… Works!”</a></li>
<li><a href="https://gitlab.torproject.org/tpo/anti-censorship/rdsys-admin/-/merge_requests/4">Use stun servers on port 3479 for turkmenistan</a></li>
</ul>
</aside>

<aside class=note id=n-73>
<a href="https://bugs.torproject.org/tpo/anti-censorship/censorship-analysis/40024#note_2829235">“So the line where we switch to port 3479 only works for some people but not others?”</a>
</aside>

<aside class=note id=n-74>
OONI stunreachability measurements
<a href="https://explorer.ooni.org/search?since=2022-07-01&amp;until=2022-10-31&amp;failure=true&amp;probe_cc=TM&amp;test_name=stunreachability">cease on <time>2023-07-31</time></a>.
</aside>

<p id=p112>
The blocking techniques described in this section are crude,
surely resulting in significant overblocking—but
they nevertheless offer greater challenges to circumvention
than the more considered blocking of, say, Russia and Iran.
We&nbsp;remark on this to make the point that blocking resistance
cannot be defined in absolute terms,
but only relative to a particular censor.
Censors differ not only in resources
(time, money, equipment, personnel),
but also in their tolerance
for the social and economic harms of overblocking.
Circumvention can only respond to and act within these constraints.
The government of Turkmenistan has evidently chosen
to prioritize political control
over a functional network, to an extreme degree.
To&nbsp;paraphrase one of our collaborators:
“What they have in Turkmenistan can hardly be called an Internet.”<a class=mark href=#fn-51><sup>51</sup></a>
In&nbsp;a network already damaged by oppressive policy,
the additional harm caused by the clumsy blocking of
this or that circumvention system is comparatively small.
This shows the sense in which a resource-poor censor
can “afford” certain blocking actions
that a richer, more capable censor cannot.
</p>

<aside class=footnote id=fn-51>
<sup>51</sup>
<a href="https://bugs.torproject.org/tpo/anti-censorship/censorship-analysis/40024#note_2889792">“And this is not a targeted Tor block, this is just how Turkmenistan blocks IP ranges.”</a>
</aside>

</section>

</section>

<section id=future data-number=6>
<h2><a href=#future><span class=number>6</span> Future work</a></h2>

<p id=p113>
We&nbsp;designed Snowflake to be useful today,
as&nbsp;well as resilient to anticipated future censorship attacks.
Here we list some research questions that affect Snowflake
and circumvention more broadly.
The uniqueness and scale of Snowflake’s deployment
provide a platform to help explore these questions.
</p>

<dl>

<dt id=p114>What could alternative Snowflake deployments look like?</dt>
<dd>
<p>
A&nbsp;natural extension of Snowflake would be
to base it on a system other than Tor, such as an ordinary VPN.
Tor has attractive privacy benefits
and a convenient framework for developing circumvention modules,
but it also has relatively low speed and lacks
support for non-TCP applications.
The prospect of multiple Snowflake deployments
raises the question of
how the proxy pool should be managed.
Building Snowflake’s population of proxies
has been an undertaking in itself—it&nbsp;would
be a regrettable duplication of effort
if every project had to repeat the process from scratch.
Rather than retrofit our existing Tor-based proxies,
a&nbsp;next-generation proxy pool might be designed
from the ground up with multiple cooperating projects in mind.
There is also the question of incentives:
while some proxy operators may be happy to donate
bandwidth to a free-to-use project like Tor,
they may need more motivation to help a commercial VPN,
for example.
</p>
</dd>

<dt id=p115>How might proxy enumeration attacks be inhibited?<a class=mark href=#n-75>&bull;</a></dt>
<dd>
<p>
The size (<a href=#proxies>Section&nbsp;4.2</a>) and churn (<a href=#proxy-churn>Section&nbsp;4.3</a>)
of the Snowflake proxy pool
are obstacles to comprehensive blocking.
However, it&nbsp;is worth considering
the maximum impact of enumeration attacks,
and ways to mitigate them while preserving usability.
</p>
</dd>

<dt id=p116>What is a good (family of) traffic shapes?</dt>
<dd>
<p>
Snowflake does not yet attempt to shape its
traffic analysis features (<a href=#fingerprinting>Section&nbsp;3</a>);
but if it were&nbsp;to, what shape should it use?
This consideration goes beyond just Snowflake.
Frameworks for proposing and evaluating
traffic shaping techniques are under-explored.
</p>
</dd>

<dt id=p117>Can traffic splitting benefit performance or resistance to blocking?<a class=mark href=#n-76>&bull;</a></dt>
<dd>
<p>
The Turbo Tunnel reliability layer of <a href=#data-transfer>Section&nbsp;2.3</a>
lets us join a sequence of proxies into a session.
In&nbsp;principle,
it&nbsp;also makes it possible to split traffic
over many proxies, not just sequentially, but simultaneously—something
like multipath&nbsp;TCP.
Sequence numbers, retransmissions, and reassembly
would ensure a reliable stream, even when proxies
have different lifetimes and performance characteristics.
Traffic splitting could reduce the performance impact of
a slow proxy, and
eliminate the brief pause for re-rendezvous
that now occurs
between consecutive proxies.
Our initial experiments did
not show enough benefit to justify the change,
though it may be a matter of tuning.<a class=mark href=#fn-52><sup>52</sup></a>
And of course,
even if there are performance and usability benefits,
analysis would be required
to determine whether simultaneous WebRTC connections
form a distinctive network fingerprint.
</p>
</dd>

</dl>

<aside class=note id=n-75>
<a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40329">TTP-03-001 WP1: Snowflake broker vulnerability</a>
</aside>

<aside class=footnote id=fn-52>
<sup>52</sup>
<ul>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/25723#note_2718643">“…the multiplexing patch in !11 makes no difference in throughput (and in some cases seems to make throughput worse)”</a></li>
<li><a href="https://gitlab.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/-/merge_requests/11#note_2716658">“At least the multiplexed version is not slower than the regular version now”</a></li>
</ul>
</aside>

<aside class=note id=n-76>
<ul>
<li><a href="https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/25723">Multiplex - one client splits traffic across multiple proxies</a></li>
<li><a href="https://lists.torproject.org/pipermail/anti-censorship-team/2020-February/000059.html">“I’m thinking of ‘striping’ packets across multiple snowflake proxies simultaneously.”</a></li>
</ul>
</aside>

</section>

<section id=availability>
<h2><a href=#availability>Availability</a></h2>

<p id=p118>
The project web site,
<a href="https://snowflake.torproject.org/">https://snowflake.torproject.org/</a>,
has links to source code
and instructions for installing the proxy browser extensions.
Code and data to reproduce
this paper and its figures are at
<a href="https://archive.org/details/snowflake-paper">https://archive.org/details/snowflake-paper</a>.
</p>

</section>

<section id=acknowledgements>
<h2><a href=#acknowledgements>Acknowledgements</a></h2>

<p id=p119>
The Snowflake project has been made possible
by the cooperation and support of many people
and organizations.
We&nbsp;want to thank particularly:
<!-- https://keroserene.net/snowflake/technical/#history -->
Chris Ball, <!-- Earliest work on extracting a WebRTC library: https://blog.printf.net/articles/2013/05/17/webrtc-without-a-signaling-server/ https://bugs.torproject.org/legacy/trac/5578#note_2111217 -->
Diogo Barradas, <!-- Provided comments on a draft -->
Griffin Boyce, <!-- Cupcake -->
Anthony Chang, <!-- SQS rendezvous -->
Roger Dingledine, <!-- Helped fund snowflake project at Tor, has contributed design input in the past -->
Sean DuBois, <!-- at Pion -->
Arthur Edelstein, <!-- Helped set up crowdfunding in 2022 (even though we later decided not to go that route): https://forum.torproject.net/t/tor-project-more-resources-required-for-snowflake-bridge/2353/4 -->
Mia Gil Epner, <!-- Coauthor of "Fingerprintability of WebRTC": https://censorbib.nymity.ch/#Fifield2016b -->
gustavo gus, <!-- Tor community team lead, helped lead response to blocking events -->
J.&nbsp;Alex Halderman,
Haz&nbsp;Æ&nbsp;41, <!-- Found an important bug affecting performance: https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40260 -->
Jordan Holland, <!-- Coauthor of "Evaluating Snowflake as an Indistinguishable Censorship Circumvention Tool" -->
Armin Huremagic, <!-- Provided Censored Planet data re Turkmenistan: https://bugs.torproject.org/tpo/anti-censorship/censorship-analysis/40024#note_2930186 -->
Ximin Luo, <!-- Early help trying to cross-compile libwebrtc: https://github.com/keroserene/go-webrtc/issues?q=commenter%3Ainfinity0 -->
Kyle MacMillan, <!-- Coauthor of "Evaluating Snowflake as an Indistinguishable Censorship Circumvention Tool" -->
Ivan Markin, <!-- First AMP cache implementation: https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/25985 (username twim) -->
meskio, <!-- Current anti-censorship team lead at Tor, has contributed to code -->
Prateek Mittal, <!-- Coauthor of "Evaluating Snowflake as an Indistinguishable Censorship Circumvention Tool" -->
Erik Nordberg, <!-- Manages finances of Snowflake Daily Operations fundraising: https://opencollective.com/censorship-circumvention/projects/snowflake-daily-operations -->
Linus Nordberg, <!-- Bridge operator; helped coordinate donations and infrastructure -->
Vern Paxson, <!-- Supervisor of Serene’s fellowship at ICSI: https://www.opentech.fund/about/people/serene-han/ -->
Michael&nbsp;Pu, <!-- SQS rendezvous -->
Kieran Quan, <!-- SQS rendezvous -->
Sukhbir Singh, <!-- Helped with Windows reproducible build in 2018: https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/25483#note_2591991 -->
Aaron Swartz,
ValdikSS, <!-- Fingerprinting research during Russia blocking: https://bugs.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/40014#note_2765074 -->
Vort, <!-- Comments on draft, bug tracker contributions: https://forum.torproject.org/t/a-draft-research-paper-about-snowflake-comments-welcome/9585/2 https://gitlab.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/-/issues/?sort=created_date&state=all&author_username=Vort -->
Andrew Wang, <!-- SQS rendezvous -->
Philipp Winter, <!-- Former anti-censorship team lead at Tor, helped discuss design and made code contributions -->
WofWca, <!-- Comments on draft, bug tracker contributions: https://forum.torproject.org/t/a-draft-research-paper-about-snowflake-comments-welcome/9585/4 https://gitlab.torproject.org/tpo/anti-censorship/pluggable-transports/snowflake/-/issues/?sort=created_date&state=all&author_username=WofWca -->
Yi&nbsp;Wei Zhou, <!-- SQS rendezvous -->
Censored Planet, <!-- Provided Censored Planet data re Turkmenistan: https://bugs.torproject.org/tpo/anti-censorship/censorship-analysis/40024#note_2930186 -->
the Counter-Power Lab at UC&nbsp;Berkeley,
Greenhost, <!-- Early hosting of bridge and continued hosting of broker -->
Guardian Project, <!-- Orbot deployment -->
Mullvad VPN, <!-- Donation of hardware for snowflake-01 bridge -->
the Net4People&nbsp;BBS and NTC forums, <!-- Discussion, testers -->
OONI, <!-- Reports, torsf and stunreachability tests -->
the Open Technology Fund, <!-- Serene’s ICFP fellowship, rapid response bridge funding April–September 2022 -->
Pion,
the Tor Project,
financial donors,
and the volunteers who run Snowflake proxies.
This work was supported in part by DARPA
under Contract No.&nbsp;FA8750-19-C-0500.
</p>

</section>

<section id=references>
<h2><a href=#references>References</a></h2>

<ol>

<li value=1 id=ref:rfc8825><p>
Harald&nbsp;T. Alvestrand.
Overview: Real-time protocols for browser-based applications.
RFC 8825, <time datetime=2021-01>January 2021</time>.
<a href="https://www.rfc-editor.org/info/rfc8825">https://www.rfc-editor.org/info/rfc8825</a>.
</p></li>

<li value=2 id=ref:Barradas2020a><p>
Diogo Barradas, Nuno Santos, Luís Rodrigues, and Vítor Nunes.
Poking a hole in the wall: Efficient censorship-resistant Internet communications by parasitizing on WebRTC.
In <i>Computer and Communications Security</i>. ACM, <time>2020</time>.
<a href="https://www.gsd.inesc-id.pt/&nbsp;nsantos/papers/barradas_ccs20.pdf">https://www.gsd.inesc-id.pt/&nbsp;nsantos/papers/barradas_ccs20.pdf</a>.
</p></li>

<li value=3 id=ref:ooni-2022-iran-blocks-social-media-mahsa-amini-protests><p>
Simone Basso, Maria Xynou, Arturo Filastò, and Amanda Meng.
Iran blocks social media, app stores and encrypted DNS amid Mahsa Amini protests, <time datetime=2022-09>September 2022</time>.
<a href="https://ooni.org/post/2022-iran-blocks-social-media-mahsa-amini-protests/">https://ooni.org/post/2022-iran-blocks-social-media-mahsa-amini-protests/</a>.
</p></li>

<li value=4 id=ref:Chen2023a><p>
Junqiang Chen, Guang Cheng, and Hantao Mei.
F-ACCUMUL: A protocol fingerprint and accumulative payload length sample-based Tor-Snowflake traffic-identifying framework.
<i>Applied Sciences</i>, 13(1), <time>2023</time>.
<a href="https://www.mdpi.com/2076-3417/13/1/622">https://www.mdpi.com/2076-3417/13/1/622</a>.
</p></li>

<li value=5 id=ref:tor-spec-negotiating-channels><p>
Roger Dingledine and Nick Mathewson.
Negotiating and initializing channels.
In <i>Tor Protocol Specification</i>. <time datetime=2024-02>February 2024</time>.
<a href="https://gitlab.torproject.org/tpo/core/torspec/-/blob/29e445bd6e9efe82367b8a2b09a6c6aa0bc92b7b/spec/tor-spec/negotiating-channels.md">https://gitlab.torproject.org/tpo/core/torspec/-/blob/29e445bd6e9efe82367b8a2b09a6c6aa0bc92b7b/spec/tor-spec/negotiating-channels.md</a>.
</p></li>

<li value=6 id=ref:rfc6066><p>
Donald&nbsp;E. Eastlake&nbsp;3rd.
Transport Layer Security (TLS) extensions: Extension definitions.
RFC 6066, <time datetime=2011-01>January 2011</time>.
<a href="https://www.rfc-editor.org/info/rfc6066">https://www.rfc-editor.org/info/rfc6066</a>.
</p></li>

<li value=7 id=ref:Feamster2003a><p>
Nick Feamster, Magdalena Balazinska, Winston Wang, Hari Balakrishnan, and David Karger.
Thwarting web censorship with untrusted messenger discovery.
In <i>Privacy Enhancing Technologies</i>. Springer, <time>2003</time>.
<a href="http://nms.csail.mit.edu/papers/disc-pet2003.pdf">http://nms.csail.mit.edu/papers/disc-pet2003.pdf</a>.
</p></li>

<li value=8 id=ref:Fifield2020a><p>
David Fifield.
Turbo Tunnel, a good way to design censorship circumvention protocols.
In <i>Free and Open Communications on the Internet</i>. USENIX, <time>2020</time>.
<a href="https://www.bamsoftware.com/papers/turbotunnel/">https://www.bamsoftware.com/papers/turbotunnel/</a>.
</p></li>

<li value=9 id=ref:arxiv.1605.08805><p>
David Fifield and Mia Gil&nbsp;Epner.
Fingerprintability of WebRTC.
<i>CoRR</i>, abs/1605.08805, <time>2016</time>.
<a href="https://arxiv.org/abs/1605.08805">https://arxiv.org/abs/1605.08805</a>.
</p></li>

<li value=10 id=ref:Fifield2012a><p>
David Fifield, Nate Hardison, Jonathan Ellithorpe, Emily Stark, Roger Dingledine, Phil Porras, and Dan Boneh.
Evading censorship with browser-based proxies.
In <i>Privacy Enhancing Technologies</i>. Springer, <time>2012</time>.
<a href="https://crypto.stanford.edu/flashproxy/flashproxy.pdf">https://crypto.stanford.edu/flashproxy/flashproxy.pdf</a>.
</p></li>

<li value=11 id=ref:Fifield2015a><p>
David Fifield, Chang Lan, Rod Hynes, Percy Wegmann, and Vern Paxson.
Blocking-resistant communication through domain fronting.
<i>Privacy Enhancing Technologies</i>, 2015(2), <time>2015</time>.
<a href="https://www.bamsoftware.com/papers/fronting/">https://www.bamsoftware.com/papers/fronting/</a>.
</p></li>

<li value=12 id=ref:Figueira2022a><p>
Gabriel Figueira, Diogo Barradas, and Nuno Santos.
Stegozoa: Enhancing WebRTC covert channels with video steganography for Internet censorship circumvention.
In <i>Asia CCS</i>. ACM, <time>2022</time>.
<a href="https://dl.acm.org/doi/10.1145/3488932.3517419">https://dl.acm.org/doi/10.1145/3488932.3517419</a>.
</p></li>

<li value=13 id=ref:Frolov2019b><p>
Sergey Frolov, Jack Wampler, Sze&nbsp;Chuen Tan, J.&nbsp;Alex Halderman, Nikita Borisov, and Eric Wustrow.
Conjure: Summoning proxies from unused address space.
In <i>Computer and Communications Security</i>. ACM, <time>2019</time>.
<a href="https://jhalderm.com/pub/papers/conjure-ccs19.pdf">https://jhalderm.com/pub/papers/conjure-ccs19.pdf</a>.
</p></li>

<li value=14 id=ref:Frolov2019a><p>
Sergey Frolov and Eric Wustrow.
The use of TLS in censorship circumvention.
In <i>Network and Distributed System Security</i>. The Internet Society, <time>2019</time>.
<a href="https://tlsfingerprint.io/static/frolov2019.pdf">https://tlsfingerprint.io/static/frolov2019.pdf</a>.
</p></li>

<li value=15 id=ref:Heule2013a><p>
Stefan Heule, Marc Nunkesser, and Alex Hall.
HyperLogLog in practice: Algorithmic engineering of a state of the art cardinality estimation algorithm.
In <i>Extending Database Technology</i>. ACM, <time>2013</time>.
<a href="https://research.google/pubs/pub40671/">https://research.google/pubs/pub40671/</a>.
</p></li>

<li value=16 id=ref:Holland2021a><p>
Jordan Holland, Paul Schmitt, Nick Feamster, and Prateek Mittal.
New directions in automated traffic analysis.
In <i>Computer and Communications Security</i>. ACM, <time>2021</time>.
<a href="https://dl.acm.org/doi/10.1145/3460120.3484758">https://dl.acm.org/doi/10.1145/3460120.3484758</a>.
</p></li>

<li value=17 id=ref:rfc8842><p>
Christer Holmberg and Roman Shpount.
Session Description Protocol (SDP) offer/answer considerations for Datagram Transport Layer Security (DTLS) and Transport Layer Security (TLS).
RFC 8842, <time datetime=2021-01>January 2021</time>.
<a href="https://www.rfc-editor.org/info/rfc8842">https://www.rfc-editor.org/info/rfc8842</a>.
</p></li>

<li value=18 id=ref:rfc8831><p>
Randell Jesup, Salvatore Loreto, and Michael Tüxen.
WebRTC data channels.
RFC 8831, <time datetime=2021-01>January 2021</time>.
<a href="https://www.rfc-editor.org/info/rfc8831">https://www.rfc-editor.org/info/rfc8831</a>.
</p></li>

<li value=19 id=ref:rfc8445><p>
Ari Keränen, Christer Holmberg, and Jonathan Rosenberg.
Interactive Connectivity Establishment (ICE): A&nbsp;protocol for network address translator (NAT) traversal.
RFC 8445, <time datetime=2018-07>July 2018</time>.
<a href="https://www.rfc-editor.org/info/rfc8445">https://www.rfc-editor.org/info/rfc8445</a>.
</p></li>

<li value=20 id=ref:Lincoln2012a><p>
Patrick Lincoln, Ian Mason, Phillip Porras, Vinod Yegneswaran, Zachary Weinberg, Jeroen Massar, William Simpson, Paul Vixie, and Dan Boneh.
Bootstrapping communications into an anti-censorship system.
In <i>Free and Open Communications on the Internet</i>. USENIX, <time>2012</time>.
<a href="https://www.usenix.org/conference/foci12/workshop-program/presentation/lincoln">https://www.usenix.org/conference/foci12/workshop-program/presentation/lincoln</a>.
</p></li>

<li value=21 id=ref:rfc5780><p>
Derek MacDonald and Bruce Lowekamp.
NAT behavior discovery using session traversal utilities for NAT (STUN).
RFC 5780, <time datetime=2010-05>May 2010</time>.
<a href="https://www.rfc-editor.org/info/rfc5780">https://www.rfc-editor.org/info/rfc5780</a>.
</p></li>

<li value=22 id=ref:arxiv.2008.03254><p>
Kyle MacMillan, Jordan Holland, and Prateek Mittal.
Evaluating Snowflake as an indistinguishable censorship circumvention tool.
<i>CoRR</i>, abs/2008.03254, <time>2020</time>.
<a href="https://arxiv.org/abs/2008.03254">https://arxiv.org/abs/2008.03254</a>.
</p></li>

<li value=23 id=ref:rfc6455><p>
Alexey Melnikov and Ian Fette.
The WebSocket protocol.
RFC 6455, <time datetime=2011-12>December 2011</time>.
<a href="https://www.rfc-editor.org/info/rfc6455">https://www.rfc-editor.org/info/rfc6455</a>.
</p></li>

<li value=24 id=ref:Nasr2020a><p>
Milad Nasr, Hadi Zolfaghari, Amir Houmansadr, and Amirhossein Ghafari.
MassBrowser: Unblocking the censored web for the masses, by the masses.
In <i>Network and Distributed System Security</i>. The Internet Society, <time>2020</time>.
<a href="https://www.ndss-symposium.org/ndss-paper/massbrowser-unblocking-the-censored-web-for-the-masses-by-the-masses/">https://www.ndss-symposium.org/ndss-paper/massbrowser-unblocking-the-censored-web-for-the-masses-by-the-masses/</a>.
</p></li>

<li value=25 id=ref:Nourin2023a><p>
Sadia Nourin, Van Tran, Xi&nbsp;Jiang, Kevin Bock, Nick Feamster, Nguyen&nbsp;Phong Hoang, and Dave Levin.
Measuring and evading Turkmenistan’s Internet censorship.
In <i>Web Conference</i>. ACM, <time>2023</time>.
<a href="https://dl.acm.org/doi/abs/10.1145/3543507.3583189">https://dl.acm.org/doi/abs/10.1145/3543507.3583189</a>.
</p></li>

<li value=26 id=ref:amp-cache><p>
OpenJS Foundation.
How AMP pages are cached.
<a href="https://amp.dev/documentation/guides-and-tutorials/learn/amp-caches-and-cors/how_amp_pages_are_cached">https://amp.dev/documentation/guides-and-tutorials/learn/amp-caches-and-cors/how_amp_pages_are_cached</a>
[cited <time>2024-03-05</time>].
</p></li>

<li value=27 id=ref:rfc8839><p>
Marc Petit-Huguenin, Suhas Nandakumar, Christer Holmberg, Ari Keränen, and Roman Shpount.
Session Description Protocol (SDP) offer/answer procedures for Interactive Connectivity Establishment (ICE).
RFC 8839, <time datetime=2021-01>January 2021</time>.
<a href="https://www.rfc-editor.org/info/rfc8839">https://www.rfc-editor.org/info/rfc8839</a>.
</p></li>

<li value=28 id=ref:rfc8489><p>
Marc Petit-Huguenin, Gonzalo Salgueiro, Jonathan Rosenberg, Dan Wing, Rohan Mahy, and Philip Matthews.
Session Traversal Utilities for NAT (STUN).
RFC 8489, <time datetime=2020-02>February 2020</time>.
<a href="https://www.rfc-editor.org/info/rfc8489">https://www.rfc-editor.org/info/rfc8489</a>.
</p></li>

<li value=29 id=ref:pion-webrtc><p>
Pion WebRTC.
<a href="https://github.com/pion/webrtc">https://github.com/pion/webrtc</a>.
</p></li>

<li value=30 id=ref:rfc8656><p>
Tirumaleswar Reddy, Alan Johnston, Philip Matthews, and Jonathan Rosenberg.
Traversal Using Relays around NAT (TURN): Relay extensions to Session Traversal Utilities for NAT (STUN).
RFC 8656, <time datetime=2020-02>February 2020</time>.
<a href="https://www.rfc-editor.org/info/rfc8656">https://www.rfc-editor.org/info/rfc8656</a>.
</p></li>

<li value=31 id=ref:rfc8827><p>
Eric Rescorla.
WebRTC security architecture.
RFC 8827, <time datetime=2021-01>January 2021</time>.
<a href="https://www.rfc-editor.org/info/rfc8827">https://www.rfc-editor.org/info/rfc8827</a>.
</p></li>

<li value=32 id=ref:rfc9147><p>
Eric Rescorla, Hannes Tschofenig, and Nagendra Modadugu.
The Datagram Transport Layer Security (DTLS) protocol version 1.3.
RFC 9147, <time datetime=2022-04>April 2022</time>.
<a href="https://www.rfc-editor.org/info/rfc9147">https://www.rfc-editor.org/info/rfc9147</a>.
</p></li>

<li value=33 id=ref:kcp><p>
skywind3000.
KCP - A&nbsp;fast and reliable ARQ protocol, <time datetime=2020-01>January 2020</time>.
<a href="https://github.com/skywind3000/kcp/blob/1.7/README.en.md">https://github.com/skywind3000/kcp/blob/1.7/README.en.md</a>.
</p></li>

<li value=34 id=ref:Raman2020c><p>
Ram Sundara&nbsp;Raman, Prerana Shenoy, Katharina Kohls, and Roya Ensafi.
Censored Planet: An Internet-wide, longitudinal censorship observatory.
In <i>Computer and Communications Security</i>. ACM, <time>2020</time>.
<a href="https://censoredplanet.org/censoredplanet">https://censoredplanet.org/censoredplanet</a>.
</p></li>

<li value=35 id=ref:tor-reproducible-metrics><p>
Tor Metrics.
Reproducible metrics.
<a href="https://metrics.torproject.org/reproducible-metrics.html">https://metrics.torproject.org/reproducible-metrics.html</a>
[cited <time>2024-03-05</time>].
</p></li>

<li value=36 id=ref:Tschantz2016a><p>
Michael&nbsp;Carl Tschantz, Sadia Afroz, Anonymous, and Vern Paxson.
SoK: Towards grounding censorship circumvention in empiricism.
In <i>Symposium on Security &amp; Privacy</i>. IEEE, <time>2016</time>.
<a href="https://internet-freedom-science.org/circumvention-survey/">https://internet-freedom-science.org/circumvention-survey/</a>.
</p></li>

<li value=37 id=ref:Umayya2023a><p>
Zeya Umayya, Dhruv Malik, Devashish Gosain, and Piyush Kumar&nbsp;Sharma.
PTPerf: On the performance evaluation of Tor pluggable transports.
In <i>Internet Measurement Conference</i>. ACM, <time>2023</time>.
<a href="https://ptperf.github.io/">https://ptperf.github.io/</a>.
</p></li>

<li value=38 id=ref:uproxy><p>
uProxy.
<a href="https://www.uproxy.org/">https://www.uproxy.org/</a>.
</p></li>

<li value=39 id=ref:uproxy-design-doc><p>
uProxy v1.2.5 - design doc.
<a href="https://docs.google.com/document/d/1t_30vX7RcrEGuWwcg0Jub-HiNI0Ko3kBOyqXgrQN3Kw">https://docs.google.com/document/d/1t_30vX7RcrEGuWwcg0Jub-HiNI0Ko3kBOyqXgrQN3Kw</a>
[cited <time>2024-03-05</time>].
Archived at <a href="https://archive.org/details/uProxy-Design-Doc-v1.2.5">https://archive.org/details/uProxy-Design-Doc-v1.2.5</a>.
</p></li>

<li value=40 id=ref:Vilalonga2023a><p>
Afonso Vilalonga, João&nbsp;S. Resende, and Henrique Domingos.
TorKameleon: Improving Tor’s censorship resistance with K-anonymization and media-based covert channels.
In <i>Trust, Security and Privacy in Computing and Communications</i>. IEEE, <time>2023</time>.
<a href="https://arxiv.org/abs/2303.17544">https://arxiv.org/abs/2303.17544</a>.
</p></li>

<li value=41 id=ref:Wails2024a><p>
Ryan Wails, George&nbsp;Arnold Sullivan, Micah Sherr, and Rob Jansen.
On precisely detecting censorship circumvention in real-world networks.
In <i>Network and Distributed System Security Symposium</i>. The Internet Society, <time>2024</time>.
<a href="https://www.robgjansen.com/publications/precisedetect-ndss2024.html">https://www.robgjansen.com/publications/precisedetect-ndss2024.html</a>.
</p></li>

<li value=42 id=ref:Xie2023a><p>
Yibo Xie, Gaopeng Gou, Gang Xiong, Zhen Li, and Mingxin Cui.
Covertness analysis of Snowflake proxy request.
In <i>Computer Supported Cooperative Work in Design</i>. IEEE, <time>2023</time>.
<a href="https://ieeexplore.ieee.org/document/10152736">https://ieeexplore.ieee.org/document/10152736</a>.
</p></li>

<li value=43 id=ref:smux><p>
xtaci.
smux, <time datetime=2023-02>February 2023</time>.
<a href="https://github.com/xtaci/smux">https://github.com/xtaci/smux</a>.
</p></li>

<li value=44 id=ref:ooni-2021-russia-blocks-tor><p>
Maria Xynou and Arturo Filastò.
Russia started blocking Tor, <time datetime=2021-12>December 2021</time>.
<a href="https://ooni.org/post/2021-russia-blocks-tor/">https://ooni.org/post/2021-russia-blocks-tor/</a>.
</p></li>

</ol>

</section>

<section id=errata>
<h2><a href=#errata>Errata</a></h2>

<dl>
<dt><time>2024-05-14</time></dt>
<dd>
<p>
The marker for <a href=#fn-20>footnote&nbsp;20</a>
was attached to the wrong sentence.
It was meant to substantiate the claim that the performance bug
was fixed in <time datetime=2023-03>mid-March 2023</time>,
not that <a href=#ref:Umayya2023a>Umayya et&nbsp;al.</a>
had independently verified performance degradation.
</p>
</dd>
</dl>

</section>

</article>
</body>
</html>
